[{"categories":["notes"],"content":"es6笔记.. ","date":"2022-06-07","objectID":"/es6%E7%AC%94%E8%AE%B001/:0:0","tags":["js","es6","笔记"],"title":"ES6笔记01","uri":"/es6%E7%AC%94%E8%AE%B001/"},{"categories":["编程"],"content":"nil 是 Go 语言中经常使用的标识符，语义上代表了很多类型的零值。相信很多 Gopher 在实际使用中都或多或少踩过 nil 的坑，比如 interface 中 nil 的含义。这篇文章希望梳理一下nil 的用法和原理。 这是 buildin/buildin.go 中对于 nil 的定义 // nil is a predeclared identifier representing the zero value for a // pointer, channel, func, interface, map, or slice type. var nil Type // Type must be a pointer, channel, func, interface, map, or slice type ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:0","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"nil 是Go语言内预置的标识符 这意味着你可以直接使用，无需额外声明。 ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:1","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"nil 是很多类型的零值 指针 Map Slice Function Channel Interface ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:2","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"nil 无默认类型 这一点非常重要，目前除了nil以外，所有的Go语言预置标识符都有一个默认类型，如 iota 的默认类型为 int。但nil 是个例外，预置的 nil 是唯一一个无默认类型的值。编译器需要足够的信息来判断一个 nil 值对应的类型。 如下代码可以通过编译： _ = (*struct{})(nil) _ = []int(nil) _ = map[int]bool(nil) _ = chan string(nil) _ = (func())(nil) _ = interface{}(nil) // 等价于 var _ *struct{} = nil var _ []int = nil var _ map[int]bool = nil var _ chan string = nil var _ func() = nil var _ interface{} = nil 下方的代码无法通过编译： var _ = nil ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:3","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"nil 并非 Go 语言的关键字 你会发现，类似下面的代码是可以通过编译的： package main import \"fmt\" func main() { nil := 123 fmt.Println(nil) // 123 } 此时 nil 已经被覆盖，并非是原来的语义，变成了一个 int 类型，值为 123的变量。若在此变量范围中继续使用 nil ，将会一直维持这个语义。 ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:4","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"nil 所占内存大小随着类型变化而变化 某个类型下所有的变量都有同样的内存结构，nil 也不例外。 package main import ( \"fmt\" \"unsafe\" ) func main() { var p *struct{} = nil fmt.Println( unsafe.Sizeof( p ) ) // 8 var s []int = nil fmt.Println( unsafe.Sizeof( s ) ) // 24 var m map[int]bool = nil fmt.Println( unsafe.Sizeof( m ) ) // 8 var c chan string = nil fmt.Println( unsafe.Sizeof( c ) ) // 8 var f func() = nil fmt.Println( unsafe.Sizeof( f ) ) // 8 var i interface{} = nil fmt.Println( unsafe.Sizeof( i ) ) // 16 } 需要注意的是，上面打印出的大小可能随着运行环境和编译器变化而改变。 ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:5","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"两个 nil 值未必相等 先来看这段代码： package main import \"fmt\" type SomeStruct struct{} func main() { var h *SomeStruct var wrapper interface{} = h fmt.Println(h == nil, wrapper == nil) // true, false } 这其实是日常 Go 开发中经常遇到的坑，h == nil 返回 true 很好理解，但为什么只是用 interface 包装了一层，就不再 == nil 了呢？ non-interface value will be converted to the type of the interface value before making the comparison. 前面我们提到过，Go预置的 nil 是没有类型的，为了让 wrapper 和 nil 进行比较，编译器会首先将 nil 转化为一个 interface{}，然后进行比较。但是注意，因为 nil 无默认类型，即便转为 interface{}，它也是没有对应的动态类型的，跟 wrapper 的动态类型*SomeStruct 不匹配，所以会返回 false。 结论：一个接口包括动态类型和动态值。如果一个接口的动态类型和动态值都为空，则这个接口为空的。如果两个被比较的 nil 值，一个是interface{}，另一个不是，那么即便可以通过编译，比较结果永远是false。 这样就可以理解，为什么下面的比较结果是 false fmt.Println( (interface{})(nil) == (*int)(nil) ) // false ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:6","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"interface 底层结构 根据 interface 是否包含有 method，底层实现上用两种 struct 来表示：iface 和 eface。eface表示不含 method 的 interface 结构，或者叫 empty interface。 eface type eface struct { _type *_type data unsafe.Pointer } type _type struct { size uintptr // type size ptrdata uintptr // size of memory prefix holding all pointers hash uint32 // hash of type; avoids computation in hash tables tflag tflag // extra type information flags align uint8 // alignment of variable with this type fieldalign uint8 // alignment of struct field with this type kind uint8 // enumeration for C alg *typeAlg // algorithm table gcdata *byte // garbage collection data str nameOff // string form ptrToThis typeOff // type for pointer to this type, may be zero } iface iface 表示 non-empty interface 的底层实现。相比于 empty interface，non-empty 要包含一些 method。method 的具体实现存放在 itab.fun 变量里。如果 interface 包含多个 method，这里只有一个 fun 变量怎么存呢？这个下面再细说。 type iface struct { tab *itab data unsafe.Pointer } // layout of Itab known to compilers // allocated in non-garbage-collected memory // Needs to be in sync with // ../cmd/compile/internal/gc/reflect.go:/^func.dumptypestructs. type itab struct { inter *interfacetype _type *_type link *itab bad int32 inhash int32 // has this itab been added to hash? fun [1]uintptr // variable sized } 概括起来，接口对象由接口表 (interface table) 指针和数据指针组成，或者说由动态类型和动态值组成。 接口表存储元数据信息，包括接口类型、动态类型，以及实现接口的方法指针。无论是反射还是通过接口调用方法，都会用到这些信息。 ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:7","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"怎么解决 interface 和 nil 的比较 上一节我们得出了结论 如果两个被比较的 nil 值，一个是interface{}，另一个不是，那么即便可以通过编译，比较结果永远是false。 但实际应用场景中，依然有 interface 和 nil 比较的诉求，很多时候我们不希望在意类型，只是希望明确当前这个 interface 动态值，是否为零值。用==显然是无法做到这一点。 这个时候我们可以借助反射的帮助来实现。 在 Golang relfect 包的文档中我们可以看到 // IsNil reports whether its argument v is nil. // The argument must be a chan, func, interface, map, pointer, or slice value; if it is not, IsNil panics. // Note that IsNil is not always equivalent to a regular comparison with nil in Go. For example, if v was created by calling ValueOf with an uninitialized interface variable i, i==nil will be true but v.IsNil will panic as v will be the zero Value. func (v Value) IsNil() bool 先将 interface 值转化为 reflect.Value，然后借用IsNil 来判断是否为空即可。 示例代码： func isNil(i interface{}) bool { return i == nil || reflect.ValueOf(i).IsNil() } 但事实上，使用reflect包下的方法一定要小心，此处入参 i 的类型为 interface{}，也就意味着任何类型的值传进来皆可，贸然使用反射，容易引发 panic。 如果 i 是一个普通的结构体，非指针类型。此处IsNil会直接抛panic，注意文档注释。 The argument must be a chan, func, interface, map, pointer, or slice value; if it is not, IsNil panics 所以，修改代码逻辑如下： func isNilFixed(i interface{}) bool { if i == nil { return true } switch reflect.TypeOf(i).Kind() { case reflect.Ptr, reflect.Map, reflect.Array, reflect.Chan, reflect.Slice: return reflect.ValueOf(i).IsNil() } return false } ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:8","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"Go 的设计是一种简单哲学，它摒弃了其他语言一些臃肿的功能和模块，以降低程序员的学习门槛，减少使用中的心智负担。 本文，我们来探讨 Go 中缺失的数据结构：Set，以及它的最佳实现方案。 ","date":"2022-04-15","objectID":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/:0:0","tags":["golang","数据结构"],"title":"go的set实现方案","uri":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"Set 语义与实现方案 Set 集合是其他语言中常见的数据结构。特性：集合中的对象不按特定的方式排序，并且没有重复对象。 学习 Go ，要记住：Go 没有包含的东西，不代表 Go 真的没有。根据 Set 特性，我们可以很轻松地想到使用 map 的实现方案（因为 map 的 key 是不重复的）：把对象当做 key 存入 map。 使用 map 来实现 Set，意味着我们只关心 key 的存在，其 value 值并不重要。有其他语言编程经验的人也许会选择 bool 来作为 value，因为它是其它语言中内存消耗最少的类型（1个字节）。但是在 Go 中，还有另一种选择：struct{}。 fmt.Println(unsafe.Sizeof(struct {}{})) // output: 0 ","date":"2022-04-15","objectID":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/:1:0","tags":["golang","数据结构"],"title":"go的set实现方案","uri":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"压测对比 为了探究哪种数据结构是作为 value 的最佳选择。我们选择了以下常用的类型作为 value 进行测试：bool、int、interface{}、struct{}。 package main import ( \"testing\" ) const num = int(1 \u003c\u003c 24) // 测试 bool 类型 func Benchmark_SetWithBoolValueWrite(b *testing.B) { set := make(map[int]bool) for i := 0; i \u003c num; i++ { set[i] = true } } // 测试 interface{} 类型 func Benchmark_SetWithInterfaceValueWrite(b *testing.B) { set := make(map[int]interface{}) for i := 0; i \u003c num; i++ { set[i] = struct{}{} } } // 测试 int 类型 func Benchmark_SetWithIntValueWrite(b *testing.B) { set := make(map[int]int) for i := 0; i \u003c num; i++ { set[i] = 0 } } // 测试 struct{} 类型 func Benchmark_SetWithStructValueWrite(b *testing.B) { set := make(map[int]struct{}) for i := 0; i \u003c num; i++ { set[i] = struct{}{} } } 我们运行以下命令，进行测试 $ go test -v -bench=. -count=3 -benchmem | tee result.txt goos: darwin goarch: amd64 pkg: workspace/example/demoForSet cpu: Intel(R) Core(TM) i5-8279U CPU @ 2.40GHz Benchmark_SetWithBoolValueWrite Benchmark_SetWithBoolValueWrite-8 1 3549312568 ns/op 883610264 B/op 614311 allocs/op Benchmark_SetWithBoolValueWrite-8 1 3288521519 ns/op 883599440 B/op 614206 allocs/op Benchmark_SetWithBoolValueWrite-8 1 3264097496 ns/op 883578624 B/op 614003 allocs/op Benchmark_SetWithInterfaceValueWrite Benchmark_SetWithInterfaceValueWrite-8 1 4397757645 ns/op 1981619632 B/op 614062 allocs/op Benchmark_SetWithInterfaceValueWrite-8 1 4088301215 ns/op 1981553392 B/op 613743 allocs/op Benchmark_SetWithInterfaceValueWrite-8 1 3990698218 ns/op 1981560880 B/op 613773 allocs/op Benchmark_SetWithIntValueWrite Benchmark_SetWithIntValueWrite-8 1 3472910194 ns/op 1412326480 B/op 615131 allocs/op Benchmark_SetWithIntValueWrite-8 1 3519755137 ns/op 1412187928 B/op 614294 allocs/op Benchmark_SetWithIntValueWrite-8 1 3459182691 ns/op 1412057672 B/op 613390 allocs/op Benchmark_SetWithStructValueWrite Benchmark_SetWithStructValueWrite-8 1 3126746088 ns/op 802452368 B/op 614127 allocs/op Benchmark_SetWithStructValueWrite-8 1 3161650835 ns/op 802431240 B/op 613632 allocs/op Benchmark_SetWithStructValueWrite-8 1 3160410871 ns/op 802440552 B/op 613748 allocs/op PASS ok workspace/example/demoForSet 42.660s 此时的结果看起来不太直观，这里推荐一个 benchmark 统计工具：Benchstat。通过以下命令进行安装 $ go get -u golang.org/x/perf/cmd/benchstat 使用 benchstat 分析刚才得到的 benchmark 结果文件 $ benchstat result.txt name time/op _SetWithBoolValueWrite-8 3.37s ± 5% _SetWithInterfaceValueWrite-8 4.16s ± 6% _SetWithIntValueWrite-8 3.48s ± 1% _SetWithStructValueWrite-8 3.15s ± 1% name alloc/op _SetWithBoolValueWrite-8 884MB ± 0% _SetWithInterfaceValueWrite-8 1.98GB ± 0% _SetWithIntValueWrite-8 1.41GB ± 0% _SetWithStructValueWrite-8 802MB ± 0% name allocs/op _SetWithBoolValueWrite-8 614k ± 0% _SetWithInterfaceValueWrite-8 614k ± 0% _SetWithIntValueWrite-8 614k ± 0% _SetWithStructValueWrite-8 614k ± 0% 从内存开销而言，struct{} 是最小的，反映在执行时间上也是最少的。由于 bool 类型仅占一个字节，它相较于空结构而言，相差的并不多。但是，如果使用 interface{} 类型，那差距就很明显了。 所以，毫无疑问，在 Set 的实现中， map 值类型应该选 struct{}。 ","date":"2022-04-15","objectID":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/:2:0","tags":["golang","数据结构"],"title":"go的set实现方案","uri":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"总结 本文虽然讨论的是 Set 的实现方案，但本质是涉及空结构体 struct{}{} 的 零内存特性。 空结构体除了是实现 Set 的 value 值最佳方案，它还可以应用于以下方面： 通知信号的 channel：当 channel 只用于通知 goroutine 的执行事件，此时 channel 就不需要发送任何实质性的数据，选择使用 chan struct{} 。 没有状态数据的结构体：当对象只拥有方法，而不包含任何的属性字段时，选择使用空结构体定义该对象。 ","date":"2022-04-15","objectID":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/:3:0","tags":["golang","数据结构"],"title":"go的set实现方案","uri":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"本文介绍 类型转换(Conversion)、类型断言(type assertion) 和类型切换（type switch)。 这三个概念类似但是又完全不同。 ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/:0:0","tags":["golang"],"title":"go的类型系统01","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/"},{"categories":["编程"],"content":"类型转换 Conversion 将一个值x转换成特定类型T,格式为 T(x),非常的简单，类型加小括号即可。 如果类型T以 *、\u003c-、func(不带结果列表)，未避免造成歧义，需要将类型括号包裹起来： (T)(x): *Point(p) // same as *(Point(p)) (*Point)(p) // p is converted to *Point \u003c-chan int(c) // same as \u003c-(chan int(c)) (\u003c-chan int)(c) // c is converted to \u003c-chan int func()(x) // function signature func() x (func())(x) // x is converted to func() (func() int)(x) // x is converted to func() int func() int(x) // x is converted to func() int (unambiguous) 并不是任意的值都可以转换成类型T, 它需要遵循一定的规则，下面一一道来。 对于一个常量值x, 如果能转换成T类型的值，它需要满足下面的条件之一: 转换常量值 x 可以表达为T的值 x 是浮点数值， T是浮点类型。 x 使用 IEEE 754 round-to-even 规则 且 IEEE -0.0 会进一步舍入到无符号的 0.0， 经过舍入后的x可以表示为T。这一条主要约束浮点数取整的规则，并不是完全按照四舍五入规则计算的。 x是一个整数而T是字符串类型 uint(iota) // iota value of type uint float32(2.718281828) // 2.718281828 of type float32 complex128(1) // 1.0 + 0.0i of type complex128 float32(0.49999999) // 0.5 of type float32 float64(-1e-1000) // 0.0 of type float64 string('x') // \"x\" of type string string(0x266c) // \"♬\" of type string MyString(\"foo\" + \"bar\") // \"foobar\" of type MyString string([]byte{'a'}) // not a constant: []byte{'a'} is not a constant (*int)(nil) // not a constant: nil is not a constant, *int is not a boolean, numeric, or string type int(1.2) // illegal: 1.2 cannot be represented as an int string(65.0) // illegal: 65.0 is not an integer constant 转换变量值 对于一个常量值x, 如果能转换成T类型的值，它需要满足下面的条件之一: x可以赋值给 T x的类型和T的底层类型 类型一致 x类型和T 都是未命名的指针类型，它们的指针指向的对象类型 类型一致 x的类型和T都是整数或者浮点数 x的类型和T都是复数 x是整数、slice of byte、slice of rune, T是字符串类型 x是字符串， T是slice of byte 或者slice of rune 数值类型和字符串之间的转换可能会改变x的呈现并且会带来运行时的花费。 其它的转换只是改变x的类型，不会改变x的呈现。 并没有直接整数和指针之间的转换。但是在前面的章节中也举例了，指针可以通过曲折的方式转换成整数， 它是通过包unsafe实现的， 甚至于你通过这种方式还可以访问struct未导出的字段。 类型不一致的两个变量不能赋值, 并且也没有什么强制类型转换的概念： var i1 int8 = 10 var i2 uint8 = i1 //错误 var i3 uint8 = (uint8)i1 //错误 比如在类型那一章讲的例子，也是通过这种类型转换实现的: x := [...]int{1, 2, 3, 4, 5} p := \u0026x[0] //p = p + 1 index2Pointer := unsafe.Pointer(uintptr(unsafe.Pointer(p)) + unsafe.Sizeof(x[0])) p = (*int)(index2Pointer) //x[1] fmt.Printf(\"%d\\n\", *p) //2 ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/:0:1","tags":["golang"],"title":"go的类型系统01","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/"},{"categories":["编程"],"content":"类型转换实践 这一节介绍常见类型一致的转换。 数值类型之间的转换 非常量的数值之间的转换遵循下面三条原则: 1、整数之间的转换时，如果值是有符号的整数，它的符号位会扩展无限大，否则零扩展，然后它会被删减以适合结果类型。怎么理解，看例子。 对于无符号数v: v := uint16(0x10F0),如果进行转换uint32(int8(v)),可以看到它的结果是0xFFFFFFF0，不会有溢出指示或者错误。 v1 := uint16(0x10F0) fmt.Printf(\"%d=%b\\n\", v1, v1) //4336=1000011110000 v2 := int8(v1) fmt.Printf(\"%d=%b\\n\", v2, v2) //-16=-10000 v3 := uint16(v2) fmt.Printf(\"%d=%b\\n\", v3, v3) //65520=1111111111110000 v4 := int16(v2) fmt.Printf(\"%d=%b\\n\", v4, v4) //-16=-10000 介绍一下。 对于v1,它是一个无符号的整数， 要把它转为有符号的int8，那么我们只看v1的后8位: 1111 0000 不幸的是，这个8位的最高位是1,我们会把它作为符号位，所以v2是个负数，那么11110000就是这个负数的补码， 那么它的原码是多少呢，计算补码的补码就是负数的原码:1001 0000,所以它是-16。如果最高位是0，简单了，本身就是它的原码。 再看v2转v3， 也就是有符号整数转无符号整数。v2是负数，内部表示为11110000,因为要扩展为16位，将符号位1扩展到最高位1111 1111 1111 0000,因为它是无符号整数，所以这个值整数的值65520。 你可以把v1值的值改为0xff60看看输出是什么？此时转换不会符号位为负数的情况。 补码（two’s complement) 指的是正数=原码，负数=反码加一 反码（ones’ complement) 指的就是通常所指的反码。 对一个整数的补码再求补码，等于该整数自身。 补码的正零与负零表示方法相同。 2、浮点数转换成整数时，小数部分被丢弃,也就是朝0方向舍入。 var v1 float32 = 0.999999 fmt.Println(int(v1)) v1 = -0.999999 fmt.Println(int(v1)) 3、当转换整数或者浮点数到浮点数的时候，或者一个复数到另一个复数， 结果值会被舍入到目标类型的精度。例如类型为float32的变量x可以通过附加的精度超过标准的IEEE-754 32-bit数， 但是float32(x)代表x的值舍入到 IEEE-754 32 bit的精度。类似地， x + 0.1 可以使用超过32 bit的精度，但是float32(x + 0.1) 肯定是32 bit的精度。 the value of a variable x of type float32 may be stored using additional precision beyond that of an IEEE-754 32-bit number, but float32(x) represents the result of rounding x’s value to 32-bit precision. Similarly, x + 0.1 may use more than 32 bits of precision, but float32(x + 0.1) does not. 关于浮点数格式IEEE-754, 随便一本计算机原理的教材中都会介绍，网上也有无数的文章介绍，它由三个域组成，float32中分别占1位、8位、和 23位,本文中就不详细介绍了。 整数和bool之间的转换 虽然有人提议实现快速的整数和bool之间的转换，但是目前看起来还没有实现，所以下面的语句是不对的： i1 := 1 i2 := 0 fmt.Printf(\"%t %t\\n\", bool(i1), bool(i2)) 但是你完全可以通过其它方式实现， 比如判断语句 n \u003e 0, 或者利用一个定义好的表(map,数组等)进行查表转换。 参考 https://github.com/golang/go/issues/6011 language: bool to numeric and numeric to bool type conversions · Issue #7657 · golang/go · GitHub 基于字节的字符串的转换 字符串代表一串字节流，所以很容易的和slice of byte, slice of rune进行转换。 1、无符号整数或者有符号整数通过它对应的UTF-8编码转换成字符串。合法的Unicode code之外的值都被转换成\\uFFFD。这里的整数也包含rune. string('a') // \"a\" string(-1) // \"\\ufffd\" == \"\\xef\\xbf\\xbd\" string(0xf8) // \"\\u00f8\" == \"ø\" == \"\\xc3\\xb8\" type MyString string MyString(0x65e5) // \"\\u65e5\" == \"日\" == \"\\xe6\\x97\\xa5\" 2、字节slice根据UTF-8编码产生字符串 string([]byte{'h', 'e', 'l', 'l', '\\xc3', '\\xb8'}) // \"hellø\" string([]byte{}) // \"\" string([]byte(nil)) // \"\" 3、将rune slice转换成字符串相当于将rune连接起来 string([]rune{0x9E1F, 0x7A9D}) // \"\\u9e1f\\u7a9d\" == \"鸟窝\" string([]rune{}) // \"\" string([]rune(nil)) // \"\" 4、将字符串转为byte slice会将字符串的字节流复制到一个byte slice 5、将一个字符串转为rune slice会将产生一个新的rune slice,包含字符串中每个rune 字符串和基本类型之间的转换 包strconv提供了字符串和基本数据类型的转换。上面我们提到了字符串和整数之间的转换，但是有时候我们需要的是将 12转换成字符串 “12”，或者从字符串中解析处一个整数，这个时候就可以使用这个包。 首先它提供了一组往byte slice增加基本类型元素的方法： func AppendBool(dst []byte, b bool) []byte func AppendFloat(dst []byte, f float64, fmt byte, prec, bitSize int) []byte func AppendInt(dst []byte, i int64, base int) []byte func AppendQuote(dst []byte, s string) []byte func AppendQuoteRune(dst []byte, r rune) []byte func AppendQuoteRuneToASCII(dst []byte, r rune) []byte func AppendQuoteRuneToGraphic(dst []byte, r rune) []byte func AppendQuoteToASCII(dst []byte, s string) []byte func AppendQuoteToGraphic(dst []byte, s string) []byte func AppendUint(dst []byte, i uint64, base int) []byte 一组从字符串中解析出基本类型的方法： func ParseBool(str string) (value bool, err error) func ParseFloat(s string, bitSize int) (f float64, err error) func ParseInt(s string, base int, bitSize int) (i int64, err error) func ParseUint(s string, base int, bitSize int) (n uint64, err error) 一组为字符串或者rune加引号和剥离引号的方法: func Quote(s string) string func QuoteRune(r rune) string func QuoteRuneToASCII(r rune) string func QuoteRuneToGraphic(r rune) string func QuoteToASCII(s string) string func QuoteToGraphic(s string) string func Unquote(s string) (t string, err error) func UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string, err error) 一组检查字符串或者rune为特定类型的方法： func CanBackquote(s string) ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/:0:2","tags":["golang"],"title":"go的类型系统01","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/"},{"categories":["编程"],"content":"类型断言 type assertion 和上节的类型转换不同，类型断言是将接口类型的值x，转换成类型T。 格式为： x.(T) v := x.(T) v, ok := x.(T) 类型断言的必要条件是x是接口类型,非接口类型的x不能做类型断言: var i int = 10 v := i.(int) //错误 T可以是非接口类型，如果想断言合法，则T应该实现x的接口。 T也可以是接口，则x的动态类型也应该实现接口T。 var x interface{} = 7 // x 的动态类型为int， 值为 7 i := x.(int) // i 的类型为 int， 值为 7 type I interface { m() } var y I s := y.(string) // 非法: string 没有实现接口 I (missing method m) r := y.(io.Reader) // y如果实现了接口io.Reader和I的情况下， r的类型则为io.Reader 类型断言如果非法，运行时时候就会出现 impossible type assertion panic，为了避免这种情况，可以使用下面的语法: v, ok = x.(T) v, ok := x.(T) var v, ok = x.(T) ok代表类型断言是否合法，如果非法ok =false,v为T的零值，这样就不会出现运行时panic了。 希望你能记住，类型转换和类型断言完全是两个概念。 ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/:0:3","tags":["golang"],"title":"go的类型系统01","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/"},{"categories":["编程"],"content":"类型切换 type switch 类型切换(暂且这么翻译吧，英语更准确)用来比较类型而不是对值进行比较。 switch语句虽然在下一章中去讲，但是对于读者来说，多少会一种或者几种常用的编程语言，switch是一个条件语句，它可以判断某个值是否匹配某个case clause。但是对于type switch，它检查的是值x的类型T是否匹配某个类型。 格式如下，类型类型断言，但是括号内的不是某个具体的类型，而是单词type: switch x.(type) { // cases } type switch语句中可以有一个简写的变量声明，这种情况下，等价于这个变量声明在每个case clause隐式代码块的开始位置。如果case clause只列出了一个类型，则变量的类型就是这个类型，否则就是原始值的类型。 假设下面的例子中x的类型为x interface{} switch i := x.(type) { case nil: printString(\"x is nil\") // i的类型是 x的类型 (interface{}) case int: printInt(i) // i的类型 int case float64: printFloat64(i) // i的类型是 float64 case func(int) float64: printFunction(i) // i的类型是 func(int) float64 case bool, string: printString(\"type is bool or string\") // i的类型是 x (interface{}) default: printString(\"don't know the type\") // i的类型是 x的类型 (interface{}) } 也许你已经看到上面的例子中有一个case clause中的类型是nil,它用来匹配x为nil的interface{}的情况。 ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/:0:4","tags":["golang"],"title":"go的类型系统01","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/"},{"categories":["编程"],"content":"本文介绍 类型别名与类型定义。 ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F02/:0:0","tags":["golang"],"title":"go的类型系统02","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F02/"},{"categories":["编程"],"content":"类型别名 类型别名需要在别名和原类型之间加上赋值符号 = ，使用类型别名定义的类型与原类型等价，Go 语言内建的基本类型中就存在两个别名类型。 byte 是 uint8 的别名类型； rune 是 int32 的别名类型； 类型别名定义形式如下： type MyString = string 上面代码表明 MyString 是 string 类型的别名类型。也就是说别名类型和源类型表示的是同一个目标，就譬如每个人的学名和乳名一样，都表示同一个人。 定义 string 类型的别名，示例代码： func main() { type MyString = string str := \"hello\" a := MyString(str) b := MyString(\"A\" + str) fmt.Printf(\"str type is %T\\n\", str) fmt.Printf(\"a type is %T\\n\", a) fmt.Printf(\"a == str is %t\\n\", a == str) fmt.Printf(\"b \u003e a is %t\\n\", b \u003e a) } 输出结果 str type is string a type is string a == str is true b \u003e a is false 定义 []string 类型的别名，示例代码： func main() { type MyString = string strs := []string{\"aa\", \"bb\", \"cc\"} a := []MyString(strs) fmt.Printf(\"strs type is %T\\n\", strs) fmt.Printf(\"a type is %T\\n\", a) fmt.Printf(\"a == nil is %t\\n\", a == nil) fmt.Printf(\"strs == nil is %t\\n\", strs != nil) } 运行结果为： strs type is []string a type is []string a == nil is false strs == nil is true 从上面结果可以得出以下结论： 别名类型与源类型是完全相同的； 别名类型与源类型可以在源类型支持的条件下进行相等判断、比较判断、与 nil 是否相等判断等； ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F02/:0:1","tags":["golang"],"title":"go的类型系统02","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F02/"},{"categories":["编程"],"content":"类型定义 类型定义是定义一种新的类型，它与源类型是不一样的。看下面代码： func main() { type MyString string str := \"hello\" a := MyString(str) b := MyString(\"A\" + str) fmt.Printf(\"str type is %T\\n\", str) fmt.Printf(\"a type is %T\\n\", a) fmt.Printf(\"a value is %#v\\n\", a) fmt.Printf(\"b value is %#v\\n\", b) // fmt.Printf(\"a == str is %t\\n\", a == str) fmt.Printf(\"b \u003e a is %t\\n\", b \u003e a) } 输出结果为： str type is string a type is main.MyString a value is \"hello\" b value is \"Ahello\" b \u003e a is false 可以看到 MyString 类型为 main.MyString 而原有的 str 类型为 string，两者是不同的类型，如果使用下面的判断相等语句 fmt.Printf(\"a == str is %t\\n\", a == str) 会有编译错误提示 invalid operation: a == str (mismatched types MyString and string) 说明类型不匹配。 下面代码 func main() { type MyString string strs := []string{\"E\", \"F\", \"G\"} myStrs := []MyString(strs) fmt.Println(myStrs) } 编译报错提示 cannot convert strs (type []string) to type []MyString 对于这里的类型再定义来说，string 可以被称为 MyString2 的潜在类型。潜在类型相同的不同类型的值之间是可以进行类型转换的。 因此，MyString2 类型的值与 string 类型的值可以使用类型转换表达式进行互转。但对于集合类的类型[]MyString2 与 []string 来说这样做却是不合法的，因为 []MyString2 与 []string 的潜在类型不同，分别是 []MyString2 和 []string 。 另外，即使两个不同类型的潜在类型相同，它们的值之间也不能进行判等或比较，它们的变量之间也不能赋值。 func main() { type MyString1 = string type MyString2 string str := \"BCD\" myStr1 := MyString1(str) myStr2 := MyString2(str) myStr1 = MyString1(myStr2) myStr2 = MyString2(myStr1) myStr1 = str myStr2 = str // cannot use str (type string) as type MyString2 in assignment myStr1 = myStr2 // cannot use myStr2 (type MyString2) as type string in assignment myStr2 = myStr1 // cannot use myStr1 (type string) as type MyString2 in assignment } ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F02/:0:2","tags":["golang"],"title":"go的类型系统02","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F02/"},{"categories":["编程"],"content":"类型别名注意点 类型循环 类型别名在定义的时候不允许出现循环定义别名的情况，如下面所示： type T1 = T2 type T2 = T1 上面的例子太明显，下面这个例子比较隐蔽，也是循环定义类型别名的情况，当然这些在编译代码的时候编译器会帮你检查，如果出现循环定义的情况会出错。 type T1 = struct { next *T2 } type T2 = T1 可导出性 如果定义的类型别名是exported (首字母大写)的，那么别的包中就可以使用，它和原始类型是否可exported没关系。也就是说，你可以为unexported类型定义一个exported的类型别名，如下面的例子： type t1 struct { S string } type T2 = t1 方法集 既然类型别名和原始类型是相同的，那么它们的方法集也是相同的。 下面的例子中T1和T3都有say和greeting方法。 type T1 struct{} type T3 = T1 func (t1 T1) say(){} func (t3 *T3) greeting(){} func main() { var t1 T1 // var t2 T2 var t3 T3 t1.say() t1.greeting() t3.say() t3.greeting() } 如果类型别名和原始类型定义了相同的方法，代码编译的时候会报错，因为有重复的方法定义。 另一个有趣的现象是 embedded type, 比如下面的例子， T3是T1的别名。在定义结构体S的时候，我们使用了匿名嵌入类型，那么这个时候调用s.say会怎么样呢？ 实际是你会编译出错，因为s.say｀不知道该调用s.T1.say还是s.T3.say`，所以这个时候你需要明确的调用。 type T1 struct{} type T3 = T1 func (t T1) say(){} type S struct { T1 T3 } func main() { var s S s.say() } 进一步想，这样是不是我们可以为其它库中的类型增加新的方法了， 比如为标准库的time.Time增加一个滴答方法: type NTime = time.Time func (t NTime) Dida() { fmt.Println(\"嘀嗒嘀嗒\") } func main() { t := time.Now() t.Dida() } 答案是: NO, 编译的时候会报错: cannot define new methods on non-local type time.Time。 ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F02/:0:3","tags":["golang"],"title":"go的类型系统02","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F02/"},{"categories":["编程"],"content":"最近在读Go源码时发现高频注释语句“XXX must not be copied after first use“。例如sync包下的Pool、Cond、WaitGroup、Mutex、Map和atomoic.Vaule、strings.Builder等，都有该句注释。 ","date":"2021-02-11","objectID":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/:0:0","tags":["golang"],"title":"go的noCopy机制","uri":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/"},{"categories":["编程"],"content":"为什么注释文档中要强调no copy？ 安全！ 如果结构体对象包含指针字段，当该对象被拷贝时，会使得两个对象中的指针字段变得不再安全。 type S struct { f1 int f2 *s } type s struct { name string } func main() { mOld := S{ f1: 0, f2: \u0026s{name: \"mike\"}, } mNew := mOld //拷贝 mNew.f1 = 1 mNew.f2.name = \"jane\" fmt.Println(mOld.f1, mOld.f2) //输出：0 \u0026{jane} } 如上，结构体对象S中存在两个field，分别是f1和f2，其中f2是指向s类型的指针。当mNew复制了mOld之后，mNew对两个字段进行了改变，可以看到f1字段的更改，不会对mOld造成影响。但是，nNew中f2字段的修改也会把mOld中的f2字段修改掉，这引发了安全问题。 ","date":"2021-02-11","objectID":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/:1:0","tags":["golang"],"title":"go的noCopy机制","uri":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/"},{"categories":["编程"],"content":"Go是如何保证no copy的？ ","date":"2021-02-11","objectID":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/:2:0","tags":["golang"],"title":"go的noCopy机制","uri":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/"},{"categories":["编程"],"content":"runtime checking strings.Builder中copy检查 func main() { var a strings.Builder a.Write([]byte(\"a\")) b := a b.Write([]byte(\"b\")) } // 运行报错：strings: illegal use of non-zero Builder copied by value 报错信息，来源于strings.Builder的copyCheck。 type Builder struct { addr *Builder // of receiver, to detect copies by value buf []byte } func (b *Builder) Write(p []byte) (int, error) { b.copyCheck() b.buf = append(b.buf, p...) return len(p), nil } func (b *Builder) copyCheck() { if b.addr == nil { b.addr = (*Builder)(noescape(unsafe.Pointer(b))) } else if b.addr != b { panic(\"strings: illegal use of non-zero Builder copied by value\") } } 在Builder中，addr是一个指向自身的指针。当对上文中的a复制给b时，a和b本身是不同的对象。因此，b.addr实际还是指向a的指针，这就会触发条件b.addr!=b，造成panic。 sync.Cond中copy检查 在源码中，拥有copy检查机制的还有sync.Cond。 type Cond struct { noCopy noCopy L Locker notify notifyList checker copyChecker } func (c *Cond) Wait() { c.checker.check() ... } type copyChecker uintptr func (c *copyChecker) check() { if uintptr(*c) != uintptr(unsafe.Pointer(c)) \u0026\u0026 !atomic.CompareAndSwapUintptr((*uintptr)(c), 0, uintptr(unsafe.Pointer(c))) \u0026\u0026 uintptr(*c) != uintptr(unsafe.Pointer(c)) { panic(\"sync.Cond is copied\") } } 这里的check函数初看不易明白。因此，定义一个相似的结构体对象，来探究这里的check函数究竟是如何做copy检查的。 type cond struct { checker copyChecker } type copyChecker uintptr func (c *copyChecker) check() { fmt.Printf(\"Before: c: %12v, *c: %12v, uintptr(*c): %12v, uintptr(unsafe.Pointer(c)): %12v\\n\", c, *c, uintptr(*c), uintptr(unsafe.Pointer(c))) swapped := atomic.CompareAndSwapUintptr((*uintptr)(c), 0, uintptr(unsafe.Pointer(c))) fmt.Printf(\"After : c: %12v, *c: %12v, uintptr(*c): %12v, uintptr(unsafe.Pointer(c)): %12v, swapped: %12v\\n\", c, *c, uintptr(*c), uintptr(unsafe.Pointer(c)), swapped) } func main() { var a cond a.checker.check() b := a b.checker.check() } // 输出 Before: c: 0xc0000b4008, *c: 0, uintptr(*c): 0, uintptr(unsafe.Pointer(c)): 824634458120 After : c: 0xc0000b4008, *c: 824634458120, uintptr(*c): 824634458120, uintptr(unsafe.Pointer(c)): 824634458120, swapped: true Before: c: 0xc0000b4040, *c: 824634458120, uintptr(*c): 824634458120, uintptr(unsafe.Pointer(c)): 824634458176 After : c: 0xc0000b4040, *c: 824634458120, uintptr(*c): 824634458120, uintptr(unsafe.Pointer(c)): 824634458176, swapped: false 这下，sync.Cond的copy检查就很清晰了。当a被b copy之后，uintptr(*c)和uintptr(unsafe.Pointer(c))的值是不同的，通过uint对象的原子比较方法CompareAndSwapUintptr将返回false，它证明了对象a被copy过，从而调用panic保护sync.Cond不被复制。 ","date":"2021-02-11","objectID":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/:2:1","tags":["golang"],"title":"go的noCopy机制","uri":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/"},{"categories":["编程"],"content":"go vet checking 上述两个例子都是在程序编译后，runtime检查的。但是，正如文中开篇所述，sync包下的其他的对象如Pool、WaitGroup、Mutex、Map等，它们其实也需要copy检查机制，但是在源码中，却没有提供运行时检查。那该如何保证我们的代码中这些对象在使用中未被copy，从而避免潜在的安全问题呢？ Go在源代码src/sync/cond.go中的一段注释给了我们答案。 // noCopy may be embedded into structs which must not be copied // after the first use. // // See https://golang.org/issues/8005#issuecomment-190753527 // for details. type noCopy struct{} // Lock is a no-op used by -copylocks checker from `go vet`. func (*noCopy) Lock() {} func (*noCopy) Unlock() {} 很明显，runtime时的copy检查虽然很重要，但是，该操作会影响程序的执行性能。Go官方目前只提供了strings.Builder和sync.Cond的runtime拷贝检查机制，对于其他需要nocopy对象类型来说，使用go vet工具来做静态编译检查。 具体实施来说，就是该对象，或对象中存在filed，它拥有Lock()和Unlock()方法，即实现sync.Locker接口。之后，可以通过go vet功能，来检查代码中该对象是否有被copy。 例如sync.Pool和sync.WaitGroup就内嵌了noCopy属性，sync.Mutex实现了sync.Locker接口，sync.Map内嵌了sync.Mutex。 静态检查 // wg.go package main import \"sync\" func main() { var sm sync.Mutex sm.Lock() sm.Unlock() sm2 := sm sm2.Lock() } 如上，sm在first use后，被copy给sm2。注意：该代码运行时，不会报错，但是却存在安全隐患。 $ go vet wg.go # command-line-arguments ./wg.go:9:9: assignment copies lock value to sm2: sync.Mutex 通过以上命令，即可检查出sync.Mutex有被copy。因此，举一反三，如果在我们自己的项目开发中，定义某对象不能被copy，那么就可以参考Go源码中，嵌入noCopy结构体，最终通过go vet进行copy检查。 type noCopy struct{} func (*noCopy) Lock() {} func (*noCopy) Unlock() {} type MyType struct { noCopy noCopy ... } ","date":"2021-02-11","objectID":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/:2:2","tags":["golang"],"title":"go的noCopy机制","uri":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"我是谁 花名池鱼，是当年加入小牛互娱时所取，选自陶渊明的《归园田居·其一》中的”羁鸟恋旧林，池鱼思故渊“，之所以选择”池鱼“作为花名，也是和作者有类型心境，不堪束缚，渴望自由。 一名手游后端开发者，目前已经在游戏行业混迹了快5年，在创业公司干过多面手，也在大公司当过螺丝钉，各种主流语言都会一点，目前专注golang。 ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"关于作者","uri":"/about/"},{"categories":null,"content":"方向 熬夜修过bug，通宵发过版，或许只有游戏人才能体会发版夜的漫长，咖啡槟榔也无法支撑起疲惫的眼皮。或许是行业红海的内卷，国家监管的出手，又或是大厂的垄断，经济的低迷，现如今纯游戏行业似乎不是那么好混了。对于非新手、非老手的我来说，有一点点尴尬，经过深思熟虑，也是对于新技术的追求，决定关注web3方面的技术，利用业余时间学习相关的新技术，也给自己在未来增加一些竞争力。 ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"关于作者","uri":"/about/"}]