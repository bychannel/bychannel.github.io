[{"categories":["notes"],"content":"es6笔记.. ","date":"2022-06-07","objectID":"/es6%E7%AC%94%E8%AE%B001/:0:0","tags":["js","es6","笔记"],"title":"ES6笔记01","uri":"/es6%E7%AC%94%E8%AE%B001/"},{"categories":["编程"],"content":"nil 是 Go 语言中经常使用的标识符，语义上代表了很多类型的零值。相信很多 Gopher 在实际使用中都或多或少踩过 nil 的坑，比如 interface 中 nil 的含义。这篇文章希望梳理一下nil 的用法和原理。 这是 buildin/buildin.go 中对于 nil 的定义 // nil is a predeclared identifier representing the zero value for a // pointer, channel, func, interface, map, or slice type. var nil Type // Type must be a pointer, channel, func, interface, map, or slice type ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:0","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"nil 是Go语言内预置的标识符 这意味着你可以直接使用，无需额外声明。 ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:1","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"nil 是很多类型的零值 指针 Map Slice Function Channel Interface ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:2","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"nil 无默认类型 这一点非常重要，目前除了nil以外，所有的Go语言预置标识符都有一个默认类型，如 iota 的默认类型为 int。但nil 是个例外，预置的 nil 是唯一一个无默认类型的值。编译器需要足够的信息来判断一个 nil 值对应的类型。 如下代码可以通过编译： _ = (*struct{})(nil) _ = []int(nil) _ = map[int]bool(nil) _ = chan string(nil) _ = (func())(nil) _ = interface{}(nil) // 等价于 var _ *struct{} = nil var _ []int = nil var _ map[int]bool = nil var _ chan string = nil var _ func() = nil var _ interface{} = nil 下方的代码无法通过编译： var _ = nil ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:3","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"nil 并非 Go 语言的关键字 你会发现，类似下面的代码是可以通过编译的： package main import \"fmt\" func main() { nil := 123 fmt.Println(nil) // 123 } 此时 nil 已经被覆盖，并非是原来的语义，变成了一个 int 类型，值为 123的变量。若在此变量范围中继续使用 nil ，将会一直维持这个语义。 ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:4","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"nil 所占内存大小随着类型变化而变化 某个类型下所有的变量都有同样的内存结构，nil 也不例外。 package main import ( \"fmt\" \"unsafe\" ) func main() { var p *struct{} = nil fmt.Println( unsafe.Sizeof( p ) ) // 8 var s []int = nil fmt.Println( unsafe.Sizeof( s ) ) // 24 var m map[int]bool = nil fmt.Println( unsafe.Sizeof( m ) ) // 8 var c chan string = nil fmt.Println( unsafe.Sizeof( c ) ) // 8 var f func() = nil fmt.Println( unsafe.Sizeof( f ) ) // 8 var i interface{} = nil fmt.Println( unsafe.Sizeof( i ) ) // 16 } 需要注意的是，上面打印出的大小可能随着运行环境和编译器变化而改变。 ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:5","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"两个 nil 值未必相等 先来看这段代码： package main import \"fmt\" type SomeStruct struct{} func main() { var h *SomeStruct var wrapper interface{} = h fmt.Println(h == nil, wrapper == nil) // true, false } 这其实是日常 Go 开发中经常遇到的坑，h == nil 返回 true 很好理解，但为什么只是用 interface 包装了一层，就不再 == nil 了呢？ non-interface value will be converted to the type of the interface value before making the comparison. 前面我们提到过，Go预置的 nil 是没有类型的，为了让 wrapper 和 nil 进行比较，编译器会首先将 nil 转化为一个 interface{}，然后进行比较。但是注意，因为 nil 无默认类型，即便转为 interface{}，它也是没有对应的动态类型的，跟 wrapper 的动态类型*SomeStruct 不匹配，所以会返回 false。 结论：一个接口包括动态类型和动态值。如果一个接口的动态类型和动态值都为空，则这个接口为空的。如果两个被比较的 nil 值，一个是interface{}，另一个不是，那么即便可以通过编译，比较结果永远是false。 这样就可以理解，为什么下面的比较结果是 false fmt.Println( (interface{})(nil) == (*int)(nil) ) // false ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:6","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"interface 底层结构 根据 interface 是否包含有 method，底层实现上用两种 struct 来表示：iface 和 eface。eface表示不含 method 的 interface 结构，或者叫 empty interface。 eface type eface struct { _type *_type data unsafe.Pointer } type _type struct { size uintptr // type size ptrdata uintptr // size of memory prefix holding all pointers hash uint32 // hash of type; avoids computation in hash tables tflag tflag // extra type information flags align uint8 // alignment of variable with this type fieldalign uint8 // alignment of struct field with this type kind uint8 // enumeration for C alg *typeAlg // algorithm table gcdata *byte // garbage collection data str nameOff // string form ptrToThis typeOff // type for pointer to this type, may be zero } iface iface 表示 non-empty interface 的底层实现。相比于 empty interface，non-empty 要包含一些 method。method 的具体实现存放在 itab.fun 变量里。如果 interface 包含多个 method，这里只有一个 fun 变量怎么存呢？这个下面再细说。 type iface struct { tab *itab data unsafe.Pointer } // layout of Itab known to compilers // allocated in non-garbage-collected memory // Needs to be in sync with // ../cmd/compile/internal/gc/reflect.go:/^func.dumptypestructs. type itab struct { inter *interfacetype _type *_type link *itab bad int32 inhash int32 // has this itab been added to hash? fun [1]uintptr // variable sized } 概括起来，接口对象由接口表 (interface table) 指针和数据指针组成，或者说由动态类型和动态值组成。 接口表存储元数据信息，包括接口类型、动态类型，以及实现接口的方法指针。无论是反射还是通过接口调用方法，都会用到这些信息。 ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:7","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"怎么解决 interface 和 nil 的比较 上一节我们得出了结论 如果两个被比较的 nil 值，一个是interface{}，另一个不是，那么即便可以通过编译，比较结果永远是false。 但实际应用场景中，依然有 interface 和 nil 比较的诉求，很多时候我们不希望在意类型，只是希望明确当前这个 interface 动态值，是否为零值。用==显然是无法做到这一点。 这个时候我们可以借助反射的帮助来实现。 在 Golang relfect 包的文档中我们可以看到 // IsNil reports whether its argument v is nil. // The argument must be a chan, func, interface, map, pointer, or slice value; if it is not, IsNil panics. // Note that IsNil is not always equivalent to a regular comparison with nil in Go. For example, if v was created by calling ValueOf with an uninitialized interface variable i, i==nil will be true but v.IsNil will panic as v will be the zero Value. func (v Value) IsNil() bool 先将 interface 值转化为 reflect.Value，然后借用IsNil 来判断是否为空即可。 示例代码： func isNil(i interface{}) bool { return i == nil || reflect.ValueOf(i).IsNil() } 但事实上，使用reflect包下的方法一定要小心，此处入参 i 的类型为 interface{}，也就意味着任何类型的值传进来皆可，贸然使用反射，容易引发 panic。 如果 i 是一个普通的结构体，非指针类型。此处IsNil会直接抛panic，注意文档注释。 The argument must be a chan, func, interface, map, pointer, or slice value; if it is not, IsNil panics 所以，修改代码逻辑如下： func isNilFixed(i interface{}) bool { if i == nil { return true } switch reflect.TypeOf(i).Kind() { case reflect.Ptr, reflect.Map, reflect.Array, reflect.Chan, reflect.Slice: return reflect.ValueOf(i).IsNil() } return false } ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:8","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"Go 的设计是一种简单哲学，它摒弃了其他语言一些臃肿的功能和模块，以降低程序员的学习门槛，减少使用中的心智负担。 本文，我们来探讨 Go 中缺失的数据结构：Set，以及它的最佳实现方案。 ","date":"2022-04-15","objectID":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/:0:0","tags":["golang","数据结构"],"title":"go的set实现方案","uri":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"Set 语义与实现方案 Set 集合是其他语言中常见的数据结构。特性：集合中的对象不按特定的方式排序，并且没有重复对象。 学习 Go ，要记住：Go 没有包含的东西，不代表 Go 真的没有。根据 Set 特性，我们可以很轻松地想到使用 map 的实现方案（因为 map 的 key 是不重复的）：把对象当做 key 存入 map。 使用 map 来实现 Set，意味着我们只关心 key 的存在，其 value 值并不重要。有其他语言编程经验的人也许会选择 bool 来作为 value，因为它是其它语言中内存消耗最少的类型（1个字节）。但是在 Go 中，还有另一种选择：struct{}。 fmt.Println(unsafe.Sizeof(struct {}{})) // output: 0 ","date":"2022-04-15","objectID":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/:1:0","tags":["golang","数据结构"],"title":"go的set实现方案","uri":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"压测对比 为了探究哪种数据结构是作为 value 的最佳选择。我们选择了以下常用的类型作为 value 进行测试：bool、int、interface{}、struct{}。 package main import ( \"testing\" ) const num = int(1 \u003c\u003c 24) // 测试 bool 类型 func Benchmark_SetWithBoolValueWrite(b *testing.B) { set := make(map[int]bool) for i := 0; i \u003c num; i++ { set[i] = true } } // 测试 interface{} 类型 func Benchmark_SetWithInterfaceValueWrite(b *testing.B) { set := make(map[int]interface{}) for i := 0; i \u003c num; i++ { set[i] = struct{}{} } } // 测试 int 类型 func Benchmark_SetWithIntValueWrite(b *testing.B) { set := make(map[int]int) for i := 0; i \u003c num; i++ { set[i] = 0 } } // 测试 struct{} 类型 func Benchmark_SetWithStructValueWrite(b *testing.B) { set := make(map[int]struct{}) for i := 0; i \u003c num; i++ { set[i] = struct{}{} } } 我们运行以下命令，进行测试 $ go test -v -bench=. -count=3 -benchmem | tee result.txt goos: darwin goarch: amd64 pkg: workspace/example/demoForSet cpu: Intel(R) Core(TM) i5-8279U CPU @ 2.40GHz Benchmark_SetWithBoolValueWrite Benchmark_SetWithBoolValueWrite-8 1 3549312568 ns/op 883610264 B/op 614311 allocs/op Benchmark_SetWithBoolValueWrite-8 1 3288521519 ns/op 883599440 B/op 614206 allocs/op Benchmark_SetWithBoolValueWrite-8 1 3264097496 ns/op 883578624 B/op 614003 allocs/op Benchmark_SetWithInterfaceValueWrite Benchmark_SetWithInterfaceValueWrite-8 1 4397757645 ns/op 1981619632 B/op 614062 allocs/op Benchmark_SetWithInterfaceValueWrite-8 1 4088301215 ns/op 1981553392 B/op 613743 allocs/op Benchmark_SetWithInterfaceValueWrite-8 1 3990698218 ns/op 1981560880 B/op 613773 allocs/op Benchmark_SetWithIntValueWrite Benchmark_SetWithIntValueWrite-8 1 3472910194 ns/op 1412326480 B/op 615131 allocs/op Benchmark_SetWithIntValueWrite-8 1 3519755137 ns/op 1412187928 B/op 614294 allocs/op Benchmark_SetWithIntValueWrite-8 1 3459182691 ns/op 1412057672 B/op 613390 allocs/op Benchmark_SetWithStructValueWrite Benchmark_SetWithStructValueWrite-8 1 3126746088 ns/op 802452368 B/op 614127 allocs/op Benchmark_SetWithStructValueWrite-8 1 3161650835 ns/op 802431240 B/op 613632 allocs/op Benchmark_SetWithStructValueWrite-8 1 3160410871 ns/op 802440552 B/op 613748 allocs/op PASS ok workspace/example/demoForSet 42.660s 此时的结果看起来不太直观，这里推荐一个 benchmark 统计工具：Benchstat。通过以下命令进行安装 $ go get -u golang.org/x/perf/cmd/benchstat 使用 benchstat 分析刚才得到的 benchmark 结果文件 $ benchstat result.txt name time/op _SetWithBoolValueWrite-8 3.37s ± 5% _SetWithInterfaceValueWrite-8 4.16s ± 6% _SetWithIntValueWrite-8 3.48s ± 1% _SetWithStructValueWrite-8 3.15s ± 1% name alloc/op _SetWithBoolValueWrite-8 884MB ± 0% _SetWithInterfaceValueWrite-8 1.98GB ± 0% _SetWithIntValueWrite-8 1.41GB ± 0% _SetWithStructValueWrite-8 802MB ± 0% name allocs/op _SetWithBoolValueWrite-8 614k ± 0% _SetWithInterfaceValueWrite-8 614k ± 0% _SetWithIntValueWrite-8 614k ± 0% _SetWithStructValueWrite-8 614k ± 0% 从内存开销而言，struct{} 是最小的，反映在执行时间上也是最少的。由于 bool 类型仅占一个字节，它相较于空结构而言，相差的并不多。但是，如果使用 interface{} 类型，那差距就很明显了。 所以，毫无疑问，在 Set 的实现中， map 值类型应该选 struct{}。 ","date":"2022-04-15","objectID":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/:2:0","tags":["golang","数据结构"],"title":"go的set实现方案","uri":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"总结 本文虽然讨论的是 Set 的实现方案，但本质是涉及空结构体 struct{}{} 的 零内存特性。 空结构体除了是实现 Set 的 value 值最佳方案，它还可以应用于以下方面： 通知信号的 channel：当 channel 只用于通知 goroutine 的执行事件，此时 channel 就不需要发送任何实质性的数据，选择使用 chan struct{} 。 没有状态数据的结构体：当对象只拥有方法，而不包含任何的属性字段时，选择使用空结构体定义该对象。 ","date":"2022-04-15","objectID":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/:3:0","tags":["golang","数据结构"],"title":"go的set实现方案","uri":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"前言 golang是一门极具设计哲学的语言，其中一点是没有支持包循环导入，目的是迫使 Go 程序员更多地考虑程序的依赖关系。一方面保持依赖关系图的简洁，二是快速的程序构建。 通常来说，只要你的包规划得好，严格规范单向调用链（如控制层-\u003e业务层-\u003e数据层），一般不会出现包循环引用问题。当然现实业务往往不会这么理想，同层级之间的不同包经常需要互相引用，下面我就分享几种解决包循环引用的方案。 ","date":"2022-04-04","objectID":"/go%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/:0:1","tags":["golang"],"title":"go循环引用优化思路","uri":"/go%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/"},{"categories":["编程"],"content":"抽象接口 package_i package package_i type PackageAInterface interface { PrintA() } type PackageBInterface interface { PrintB() } package_a package package_a import ( \"cycle/package_i\" \"fmt\" ) type PackageA struct { B package_i.PackageBInterface } func (a PackageA) PrintA() { fmt.Println(\"I'm a!\") } func (a PackageA) PrintAll() { a.PrintA() a.B.PrintB() } package_b package package_b import ( \"cycle/package_i\" \"fmt\" ) type PackageB struct { A package_i.PackageAInterface } func (b PackageB) PrintB() { fmt.Println(\"I'm b!\") } func (b PackageB) PrintAll() { b.PrintB() b.A.PrintA() } main package main import ( \"cycle/package_a\" \"cycle/package_b\" ) func main() { a := new(package_a.PackageA) b := new(package_b.PackageB) a.B = b b.A = a a.PrintAll() b.PrintAll() } ","date":"2022-04-04","objectID":"/go%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/:0:2","tags":["golang"],"title":"go循环引用优化思路","uri":"/go%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/"},{"categories":["编程"],"content":"三、新建公共组合包（子包），在组合包中组合调用 package_c package package_c import ( \"cycle/package_a\" \"cycle/package_b\" ) type CombileAB struct { A *package_a.PackageA B *package_b.PackageB } func (c CombileAB) PrintAll() { c.A.PrintA() c.B.PrintB() } main package main import ( \"cycle/package_a\" \"cycle/package_b\" \"cycle/package_c\" ) func main() { a := new(package_a.PackageA) b := new(package_b.PackageB) c := new(package_c.CombileAB) c.A = a c.B = b c.PrintAll() } ","date":"2022-04-04","objectID":"/go%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/:1:0","tags":["golang"],"title":"go循环引用优化思路","uri":"/go%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/"},{"categories":["编程"],"content":"四、全局存储需要相互依赖的函数，通过关键字进行调用 callback_mgr package callback_mgr import ( \"fmt\" \"reflect\" ) var callBackMap map[string]interface{} func init() { callBackMap = make(map[string]interface{}) } func RegisterCallBack(key string, callBack interface{}) { callBackMap[key] = callBack } func CallBackFunc(key string, args ...interface{}) []interface{} { if callBack, ok := callBackMap[key]; ok { in := make([]reflect.Value, len(args)) for i, arg := range args { in[i] = reflect.ValueOf(arg) } outList := reflect.ValueOf(callBack).Call(in) result := make([]interface{}, len(outList)) for i, out := range outList { result[i] = out.Interface() } return result } else { panic(fmt.Errorf(\"callBack(%s) not found\", key)) } } package_a package package_a import ( \"cycle/callback_mgr\" \"fmt\" ) func init() { callback_mgr.RegisterCallBack(\"getA\", new(PackageA).GetA) } type PackageA struct { } func (a PackageA) GetA() string { return \"I'm a!\" } func (a PackageA) PrintAll() { fmt.Println(a.GetA()) fmt.Println(callback_mgr.CallBackFunc(\"getB\")[0].(string)) } package_b package package_b import ( \"cycle/callback_mgr\" \"fmt\" ) func init() { callback_mgr.RegisterCallBack(\"getB\", new(PackageB).GetB) } type PackageB struct { } func (b PackageB) GetB() string { return \"I'm b!\" } func (b PackageB) PrintAll() { fmt.Println(b.GetB()) fmt.Println(callback_mgr.CallBackFunc(\"getA\")[0].(string)) } main package main import ( \"cycle/package_a\" \"cycle/package_b\" ) func main() { a := new(package_a.PackageA) b := new(package_b.PackageB) a.PrintAll() b.PrintAll() } ","date":"2022-04-04","objectID":"/go%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/:2:0","tags":["golang"],"title":"go循环引用优化思路","uri":"/go%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/"},{"categories":["编程"],"content":"异步调用解耦 对于不需要执行结果的方法调用，可以采用事件总线进行异步调用。 eventBus package eventBus import ( \"github.com/asaskevich/EventBus\" ) var globalEventBus EventBus.Bus func init() { globalEventBus = EventBus.New() } func Subscribe(topic string, fn interface{}) error { return globalEventBus.Subscribe(topic, fn) } func SubscribeAsync(topic string, fn interface{}, transactional bool) error { return globalEventBus.SubscribeAsync(topic, fn, transactional) } func Publish(topic string, args ...interface{}) { globalEventBus.Publish(topic, args...) } package_a package package_a import ( \"cycle/eventBus\" \"fmt\" ) func init() { eventBus.Subscribe(\"PrintA\", new(PackageA).PrintA) } type PackageA struct { } func (a PackageA) PrintA() { fmt.Println(\"I'm a!\") } func (a PackageA) PrintAll() { a.PrintA() eventBus.Publish(\"PrintB\") } package_b package package_b import ( \"cycle/eventBus\" \"fmt\" ) func init() { eventBus.Subscribe(\"PrintB\", new(PackageB).PrintB) } type PackageB struct { } func (b PackageB) PrintB() { fmt.Println(\"I'm b!\") } func (b PackageB) PrintAll() { b.PrintB() eventBus.Publish(\"PrintA\") } ","date":"2022-04-04","objectID":"/go%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/:2:1","tags":["golang"],"title":"go循环引用优化思路","uri":"/go%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/"},{"categories":["编程"],"content":"本文介绍 类型转换(Conversion)、类型断言(type assertion) 和类型切换（type switch)。 这三个概念类似但是又完全不同。 ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/:0:0","tags":["golang"],"title":"go的类型系统01","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/"},{"categories":["编程"],"content":"类型转换 Conversion 将一个值x转换成特定类型T,格式为 T(x),非常的简单，类型加小括号即可。 如果类型T以 *、\u003c-、func(不带结果列表)，未避免造成歧义，需要将类型括号包裹起来： (T)(x): *Point(p) // same as *(Point(p)) (*Point)(p) // p is converted to *Point \u003c-chan int(c) // same as \u003c-(chan int(c)) (\u003c-chan int)(c) // c is converted to \u003c-chan int func()(x) // function signature func() x (func())(x) // x is converted to func() (func() int)(x) // x is converted to func() int func() int(x) // x is converted to func() int (unambiguous) 并不是任意的值都可以转换成类型T, 它需要遵循一定的规则，下面一一道来。 对于一个常量值x, 如果能转换成T类型的值，它需要满足下面的条件之一: 转换常量值 x 可以表达为T的值 x 是浮点数值， T是浮点类型。 x 使用 IEEE 754 round-to-even 规则 且 IEEE -0.0 会进一步舍入到无符号的 0.0， 经过舍入后的x可以表示为T。这一条主要约束浮点数取整的规则，并不是完全按照四舍五入规则计算的。 x是一个整数而T是字符串类型 uint(iota) // iota value of type uint float32(2.718281828) // 2.718281828 of type float32 complex128(1) // 1.0 + 0.0i of type complex128 float32(0.49999999) // 0.5 of type float32 float64(-1e-1000) // 0.0 of type float64 string('x') // \"x\" of type string string(0x266c) // \"♬\" of type string MyString(\"foo\" + \"bar\") // \"foobar\" of type MyString string([]byte{'a'}) // not a constant: []byte{'a'} is not a constant (*int)(nil) // not a constant: nil is not a constant, *int is not a boolean, numeric, or string type int(1.2) // illegal: 1.2 cannot be represented as an int string(65.0) // illegal: 65.0 is not an integer constant 转换变量值 对于一个常量值x, 如果能转换成T类型的值，它需要满足下面的条件之一: x可以赋值给 T x的类型和T的底层类型 类型一致 x类型和T 都是未命名的指针类型，它们的指针指向的对象类型 类型一致 x的类型和T都是整数或者浮点数 x的类型和T都是复数 x是整数、slice of byte、slice of rune, T是字符串类型 x是字符串， T是slice of byte 或者slice of rune 数值类型和字符串之间的转换可能会改变x的呈现并且会带来运行时的花费。 其它的转换只是改变x的类型，不会改变x的呈现。 并没有直接整数和指针之间的转换。但是在前面的章节中也举例了，指针可以通过曲折的方式转换成整数， 它是通过包unsafe实现的， 甚至于你通过这种方式还可以访问struct未导出的字段。 类型不一致的两个变量不能赋值, 并且也没有什么强制类型转换的概念： var i1 int8 = 10 var i2 uint8 = i1 //错误 var i3 uint8 = (uint8)i1 //错误 比如在类型那一章讲的例子，也是通过这种类型转换实现的: x := [...]int{1, 2, 3, 4, 5} p := \u0026x[0] //p = p + 1 index2Pointer := unsafe.Pointer(uintptr(unsafe.Pointer(p)) + unsafe.Sizeof(x[0])) p = (*int)(index2Pointer) //x[1] fmt.Printf(\"%d\\n\", *p) //2 ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/:0:1","tags":["golang"],"title":"go的类型系统01","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/"},{"categories":["编程"],"content":"类型转换实践 这一节介绍常见类型一致的转换。 数值类型之间的转换 非常量的数值之间的转换遵循下面三条原则: 1、整数之间的转换时，如果值是有符号的整数，它的符号位会扩展无限大，否则零扩展，然后它会被删减以适合结果类型。怎么理解，看例子。 对于无符号数v: v := uint16(0x10F0),如果进行转换uint32(int8(v)),可以看到它的结果是0xFFFFFFF0，不会有溢出指示或者错误。 v1 := uint16(0x10F0) fmt.Printf(\"%d=%b\\n\", v1, v1) //4336=1000011110000 v2 := int8(v1) fmt.Printf(\"%d=%b\\n\", v2, v2) //-16=-10000 v3 := uint16(v2) fmt.Printf(\"%d=%b\\n\", v3, v3) //65520=1111111111110000 v4 := int16(v2) fmt.Printf(\"%d=%b\\n\", v4, v4) //-16=-10000 介绍一下。 对于v1,它是一个无符号的整数， 要把它转为有符号的int8，那么我们只看v1的后8位: 1111 0000 不幸的是，这个8位的最高位是1,我们会把它作为符号位，所以v2是个负数，那么11110000就是这个负数的补码， 那么它的原码是多少呢，计算补码的补码就是负数的原码:1001 0000,所以它是-16。如果最高位是0，简单了，本身就是它的原码。 再看v2转v3， 也就是有符号整数转无符号整数。v2是负数，内部表示为11110000,因为要扩展为16位，将符号位1扩展到最高位1111 1111 1111 0000,因为它是无符号整数，所以这个值整数的值65520。 你可以把v1值的值改为0xff60看看输出是什么？此时转换不会符号位为负数的情况。 补码（two’s complement) 指的是正数=原码，负数=反码加一 反码（ones’ complement) 指的就是通常所指的反码。 对一个整数的补码再求补码，等于该整数自身。 补码的正零与负零表示方法相同。 2、浮点数转换成整数时，小数部分被丢弃,也就是朝0方向舍入。 var v1 float32 = 0.999999 fmt.Println(int(v1)) v1 = -0.999999 fmt.Println(int(v1)) 3、当转换整数或者浮点数到浮点数的时候，或者一个复数到另一个复数， 结果值会被舍入到目标类型的精度。例如类型为float32的变量x可以通过附加的精度超过标准的IEEE-754 32-bit数， 但是float32(x)代表x的值舍入到 IEEE-754 32 bit的精度。类似地， x + 0.1 可以使用超过32 bit的精度，但是float32(x + 0.1) 肯定是32 bit的精度。 the value of a variable x of type float32 may be stored using additional precision beyond that of an IEEE-754 32-bit number, but float32(x) represents the result of rounding x’s value to 32-bit precision. Similarly, x + 0.1 may use more than 32 bits of precision, but float32(x + 0.1) does not. 关于浮点数格式IEEE-754, 随便一本计算机原理的教材中都会介绍，网上也有无数的文章介绍，它由三个域组成，float32中分别占1位、8位、和 23位,本文中就不详细介绍了。 整数和bool之间的转换 虽然有人提议实现快速的整数和bool之间的转换，但是目前看起来还没有实现，所以下面的语句是不对的： i1 := 1 i2 := 0 fmt.Printf(\"%t %t\\n\", bool(i1), bool(i2)) 但是你完全可以通过其它方式实现， 比如判断语句 n \u003e 0, 或者利用一个定义好的表(map,数组等)进行查表转换。 参考 https://github.com/golang/go/issues/6011 language: bool to numeric and numeric to bool type conversions · Issue #7657 · golang/go · GitHub 基于字节的字符串的转换 字符串代表一串字节流，所以很容易的和slice of byte, slice of rune进行转换。 1、无符号整数或者有符号整数通过它对应的UTF-8编码转换成字符串。合法的Unicode code之外的值都被转换成\\uFFFD。这里的整数也包含rune. string('a') // \"a\" string(-1) // \"\\ufffd\" == \"\\xef\\xbf\\xbd\" string(0xf8) // \"\\u00f8\" == \"ø\" == \"\\xc3\\xb8\" type MyString string MyString(0x65e5) // \"\\u65e5\" == \"日\" == \"\\xe6\\x97\\xa5\" 2、字节slice根据UTF-8编码产生字符串 string([]byte{'h', 'e', 'l', 'l', '\\xc3', '\\xb8'}) // \"hellø\" string([]byte{}) // \"\" string([]byte(nil)) // \"\" 3、将rune slice转换成字符串相当于将rune连接起来 string([]rune{0x9E1F, 0x7A9D}) // \"\\u9e1f\\u7a9d\" == \"鸟窝\" string([]rune{}) // \"\" string([]rune(nil)) // \"\" 4、将字符串转为byte slice会将字符串的字节流复制到一个byte slice 5、将一个字符串转为rune slice会将产生一个新的rune slice,包含字符串中每个rune 字符串和基本类型之间的转换 包strconv提供了字符串和基本数据类型的转换。上面我们提到了字符串和整数之间的转换，但是有时候我们需要的是将 12转换成字符串 “12”，或者从字符串中解析处一个整数，这个时候就可以使用这个包。 首先它提供了一组往byte slice增加基本类型元素的方法： func AppendBool(dst []byte, b bool) []byte func AppendFloat(dst []byte, f float64, fmt byte, prec, bitSize int) []byte func AppendInt(dst []byte, i int64, base int) []byte func AppendQuote(dst []byte, s string) []byte func AppendQuoteRune(dst []byte, r rune) []byte func AppendQuoteRuneToASCII(dst []byte, r rune) []byte func AppendQuoteRuneToGraphic(dst []byte, r rune) []byte func AppendQuoteToASCII(dst []byte, s string) []byte func AppendQuoteToGraphic(dst []byte, s string) []byte func AppendUint(dst []byte, i uint64, base int) []byte 一组从字符串中解析出基本类型的方法： func ParseBool(str string) (value bool, err error) func ParseFloat(s string, bitSize int) (f float64, err error) func ParseInt(s string, base int, bitSize int) (i int64, err error) func ParseUint(s string, base int, bitSize int) (n uint64, err error) 一组为字符串或者rune加引号和剥离引号的方法: func Quote(s string) string func QuoteRune(r rune) string func QuoteRuneToASCII(r rune) string func QuoteRuneToGraphic(r rune) string func QuoteToASCII(s string) string func QuoteToGraphic(s string) string func Unquote(s string) (t string, err error) func UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string, err error) 一组检查字符串或者rune为特定类型的方法： func CanBackquote(s string) ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/:0:2","tags":["golang"],"title":"go的类型系统01","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/"},{"categories":["编程"],"content":"类型断言 type assertion 和上节的类型转换不同，类型断言是将接口类型的值x，转换成类型T。 格式为： x.(T) v := x.(T) v, ok := x.(T) 类型断言的必要条件是x是接口类型,非接口类型的x不能做类型断言: var i int = 10 v := i.(int) //错误 T可以是非接口类型，如果想断言合法，则T应该实现x的接口。 T也可以是接口，则x的动态类型也应该实现接口T。 var x interface{} = 7 // x 的动态类型为int， 值为 7 i := x.(int) // i 的类型为 int， 值为 7 type I interface { m() } var y I s := y.(string) // 非法: string 没有实现接口 I (missing method m) r := y.(io.Reader) // y如果实现了接口io.Reader和I的情况下， r的类型则为io.Reader 类型断言如果非法，运行时时候就会出现 impossible type assertion panic，为了避免这种情况，可以使用下面的语法: v, ok = x.(T) v, ok := x.(T) var v, ok = x.(T) ok代表类型断言是否合法，如果非法ok =false,v为T的零值，这样就不会出现运行时panic了。 希望你能记住，类型转换和类型断言完全是两个概念。 ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/:0:3","tags":["golang"],"title":"go的类型系统01","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/"},{"categories":["编程"],"content":"类型切换 type switch 类型切换(暂且这么翻译吧，英语更准确)用来比较类型而不是对值进行比较。 switch语句虽然在下一章中去讲，但是对于读者来说，多少会一种或者几种常用的编程语言，switch是一个条件语句，它可以判断某个值是否匹配某个case clause。但是对于type switch，它检查的是值x的类型T是否匹配某个类型。 格式如下，类型类型断言，但是括号内的不是某个具体的类型，而是单词type: switch x.(type) { // cases } type switch语句中可以有一个简写的变量声明，这种情况下，等价于这个变量声明在每个case clause隐式代码块的开始位置。如果case clause只列出了一个类型，则变量的类型就是这个类型，否则就是原始值的类型。 假设下面的例子中x的类型为x interface{} switch i := x.(type) { case nil: printString(\"x is nil\") // i的类型是 x的类型 (interface{}) case int: printInt(i) // i的类型 int case float64: printFloat64(i) // i的类型是 float64 case func(int) float64: printFunction(i) // i的类型是 func(int) float64 case bool, string: printString(\"type is bool or string\") // i的类型是 x (interface{}) default: printString(\"don't know the type\") // i的类型是 x的类型 (interface{}) } 也许你已经看到上面的例子中有一个case clause中的类型是nil,它用来匹配x为nil的interface{}的情况。 ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/:0:4","tags":["golang"],"title":"go的类型系统01","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/"},{"categories":["编程"],"content":"本文介绍 类型别名与类型定义。 ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F02/:0:0","tags":["golang"],"title":"go的类型系统02","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F02/"},{"categories":["编程"],"content":"类型别名 类型别名需要在别名和原类型之间加上赋值符号 = ，使用类型别名定义的类型与原类型等价，Go 语言内建的基本类型中就存在两个别名类型。 byte 是 uint8 的别名类型； rune 是 int32 的别名类型； 类型别名定义形式如下： type MyString = string 上面代码表明 MyString 是 string 类型的别名类型。也就是说别名类型和源类型表示的是同一个目标，就譬如每个人的学名和乳名一样，都表示同一个人。 定义 string 类型的别名，示例代码： func main() { type MyString = string str := \"hello\" a := MyString(str) b := MyString(\"A\" + str) fmt.Printf(\"str type is %T\\n\", str) fmt.Printf(\"a type is %T\\n\", a) fmt.Printf(\"a == str is %t\\n\", a == str) fmt.Printf(\"b \u003e a is %t\\n\", b \u003e a) } 输出结果 str type is string a type is string a == str is true b \u003e a is false 定义 []string 类型的别名，示例代码： func main() { type MyString = string strs := []string{\"aa\", \"bb\", \"cc\"} a := []MyString(strs) fmt.Printf(\"strs type is %T\\n\", strs) fmt.Printf(\"a type is %T\\n\", a) fmt.Printf(\"a == nil is %t\\n\", a == nil) fmt.Printf(\"strs == nil is %t\\n\", strs != nil) } 运行结果为： strs type is []string a type is []string a == nil is false strs == nil is true 从上面结果可以得出以下结论： 别名类型与源类型是完全相同的； 别名类型与源类型可以在源类型支持的条件下进行相等判断、比较判断、与 nil 是否相等判断等； ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F02/:0:1","tags":["golang"],"title":"go的类型系统02","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F02/"},{"categories":["编程"],"content":"类型定义 类型定义是定义一种新的类型，它与源类型是不一样的。看下面代码： func main() { type MyString string str := \"hello\" a := MyString(str) b := MyString(\"A\" + str) fmt.Printf(\"str type is %T\\n\", str) fmt.Printf(\"a type is %T\\n\", a) fmt.Printf(\"a value is %#v\\n\", a) fmt.Printf(\"b value is %#v\\n\", b) // fmt.Printf(\"a == str is %t\\n\", a == str) fmt.Printf(\"b \u003e a is %t\\n\", b \u003e a) } 输出结果为： str type is string a type is main.MyString a value is \"hello\" b value is \"Ahello\" b \u003e a is false 可以看到 MyString 类型为 main.MyString 而原有的 str 类型为 string，两者是不同的类型，如果使用下面的判断相等语句 fmt.Printf(\"a == str is %t\\n\", a == str) 会有编译错误提示 invalid operation: a == str (mismatched types MyString and string) 说明类型不匹配。 下面代码 func main() { type MyString string strs := []string{\"E\", \"F\", \"G\"} myStrs := []MyString(strs) fmt.Println(myStrs) } 编译报错提示 cannot convert strs (type []string) to type []MyString 对于这里的类型再定义来说，string 可以被称为 MyString2 的潜在类型。潜在类型相同的不同类型的值之间是可以进行类型转换的。 因此，MyString2 类型的值与 string 类型的值可以使用类型转换表达式进行互转。但对于集合类的类型[]MyString2 与 []string 来说这样做却是不合法的，因为 []MyString2 与 []string 的潜在类型不同，分别是 []MyString2 和 []string 。 另外，即使两个不同类型的潜在类型相同，它们的值之间也不能进行判等或比较，它们的变量之间也不能赋值。 func main() { type MyString1 = string type MyString2 string str := \"BCD\" myStr1 := MyString1(str) myStr2 := MyString2(str) myStr1 = MyString1(myStr2) myStr2 = MyString2(myStr1) myStr1 = str myStr2 = str // cannot use str (type string) as type MyString2 in assignment myStr1 = myStr2 // cannot use myStr2 (type MyString2) as type string in assignment myStr2 = myStr1 // cannot use myStr1 (type string) as type MyString2 in assignment } ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F02/:0:2","tags":["golang"],"title":"go的类型系统02","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F02/"},{"categories":["编程"],"content":"类型别名注意点 类型循环 类型别名在定义的时候不允许出现循环定义别名的情况，如下面所示： type T1 = T2 type T2 = T1 上面的例子太明显，下面这个例子比较隐蔽，也是循环定义类型别名的情况，当然这些在编译代码的时候编译器会帮你检查，如果出现循环定义的情况会出错。 type T1 = struct { next *T2 } type T2 = T1 可导出性 如果定义的类型别名是exported (首字母大写)的，那么别的包中就可以使用，它和原始类型是否可exported没关系。也就是说，你可以为unexported类型定义一个exported的类型别名，如下面的例子： type t1 struct { S string } type T2 = t1 方法集 既然类型别名和原始类型是相同的，那么它们的方法集也是相同的。 下面的例子中T1和T3都有say和greeting方法。 type T1 struct{} type T3 = T1 func (t1 T1) say(){} func (t3 *T3) greeting(){} func main() { var t1 T1 // var t2 T2 var t3 T3 t1.say() t1.greeting() t3.say() t3.greeting() } 如果类型别名和原始类型定义了相同的方法，代码编译的时候会报错，因为有重复的方法定义。 另一个有趣的现象是 embedded type, 比如下面的例子， T3是T1的别名。在定义结构体S的时候，我们使用了匿名嵌入类型，那么这个时候调用s.say会怎么样呢？ 实际是你会编译出错，因为s.say｀不知道该调用s.T1.say还是s.T3.say`，所以这个时候你需要明确的调用。 type T1 struct{} type T3 = T1 func (t T1) say(){} type S struct { T1 T3 } func main() { var s S s.say() } 进一步想，这样是不是我们可以为其它库中的类型增加新的方法了， 比如为标准库的time.Time增加一个滴答方法: type NTime = time.Time func (t NTime) Dida() { fmt.Println(\"嘀嗒嘀嗒\") } func main() { t := time.Now() t.Dida() } 答案是: NO, 编译的时候会报错: cannot define new methods on non-local type time.Time。 ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F02/:0:3","tags":["golang"],"title":"go的类型系统02","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F02/"},{"categories":["编程"],"content":"最近在读Go源码时发现高频注释语句“XXX must not be copied after first use“。例如sync包下的Pool、Cond、WaitGroup、Mutex、Map和atomoic.Vaule、strings.Builder等，都有该句注释。 ","date":"2021-02-11","objectID":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/:0:0","tags":["golang"],"title":"go的noCopy机制","uri":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/"},{"categories":["编程"],"content":"为什么注释文档中要强调no copy？ 安全！ 如果结构体对象包含指针字段，当该对象被拷贝时，会使得两个对象中的指针字段变得不再安全。 type S struct { f1 int f2 *s } type s struct { name string } func main() { mOld := S{ f1: 0, f2: \u0026s{name: \"mike\"}, } mNew := mOld //拷贝 mNew.f1 = 1 mNew.f2.name = \"jane\" fmt.Println(mOld.f1, mOld.f2) //输出：0 \u0026{jane} } 如上，结构体对象S中存在两个field，分别是f1和f2，其中f2是指向s类型的指针。当mNew复制了mOld之后，mNew对两个字段进行了改变，可以看到f1字段的更改，不会对mOld造成影响。但是，nNew中f2字段的修改也会把mOld中的f2字段修改掉，这引发了安全问题。 ","date":"2021-02-11","objectID":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/:1:0","tags":["golang"],"title":"go的noCopy机制","uri":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/"},{"categories":["编程"],"content":"Go是如何保证no copy的？ ","date":"2021-02-11","objectID":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/:2:0","tags":["golang"],"title":"go的noCopy机制","uri":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/"},{"categories":["编程"],"content":"runtime checking strings.Builder中copy检查 func main() { var a strings.Builder a.Write([]byte(\"a\")) b := a b.Write([]byte(\"b\")) } // 运行报错：strings: illegal use of non-zero Builder copied by value 报错信息，来源于strings.Builder的copyCheck。 type Builder struct { addr *Builder // of receiver, to detect copies by value buf []byte } func (b *Builder) Write(p []byte) (int, error) { b.copyCheck() b.buf = append(b.buf, p...) return len(p), nil } func (b *Builder) copyCheck() { if b.addr == nil { b.addr = (*Builder)(noescape(unsafe.Pointer(b))) } else if b.addr != b { panic(\"strings: illegal use of non-zero Builder copied by value\") } } 在Builder中，addr是一个指向自身的指针。当对上文中的a复制给b时，a和b本身是不同的对象。因此，b.addr实际还是指向a的指针，这就会触发条件b.addr!=b，造成panic。 sync.Cond中copy检查 在源码中，拥有copy检查机制的还有sync.Cond。 type Cond struct { noCopy noCopy L Locker notify notifyList checker copyChecker } func (c *Cond) Wait() { c.checker.check() ... } type copyChecker uintptr func (c *copyChecker) check() { if uintptr(*c) != uintptr(unsafe.Pointer(c)) \u0026\u0026 !atomic.CompareAndSwapUintptr((*uintptr)(c), 0, uintptr(unsafe.Pointer(c))) \u0026\u0026 uintptr(*c) != uintptr(unsafe.Pointer(c)) { panic(\"sync.Cond is copied\") } } 这里的check函数初看不易明白。因此，定义一个相似的结构体对象，来探究这里的check函数究竟是如何做copy检查的。 type cond struct { checker copyChecker } type copyChecker uintptr func (c *copyChecker) check() { fmt.Printf(\"Before: c: %12v, *c: %12v, uintptr(*c): %12v, uintptr(unsafe.Pointer(c)): %12v\\n\", c, *c, uintptr(*c), uintptr(unsafe.Pointer(c))) swapped := atomic.CompareAndSwapUintptr((*uintptr)(c), 0, uintptr(unsafe.Pointer(c))) fmt.Printf(\"After : c: %12v, *c: %12v, uintptr(*c): %12v, uintptr(unsafe.Pointer(c)): %12v, swapped: %12v\\n\", c, *c, uintptr(*c), uintptr(unsafe.Pointer(c)), swapped) } func main() { var a cond a.checker.check() b := a b.checker.check() } // 输出 Before: c: 0xc0000b4008, *c: 0, uintptr(*c): 0, uintptr(unsafe.Pointer(c)): 824634458120 After : c: 0xc0000b4008, *c: 824634458120, uintptr(*c): 824634458120, uintptr(unsafe.Pointer(c)): 824634458120, swapped: true Before: c: 0xc0000b4040, *c: 824634458120, uintptr(*c): 824634458120, uintptr(unsafe.Pointer(c)): 824634458176 After : c: 0xc0000b4040, *c: 824634458120, uintptr(*c): 824634458120, uintptr(unsafe.Pointer(c)): 824634458176, swapped: false 这下，sync.Cond的copy检查就很清晰了。当a被b copy之后，uintptr(*c)和uintptr(unsafe.Pointer(c))的值是不同的，通过uint对象的原子比较方法CompareAndSwapUintptr将返回false，它证明了对象a被copy过，从而调用panic保护sync.Cond不被复制。 ","date":"2021-02-11","objectID":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/:2:1","tags":["golang"],"title":"go的noCopy机制","uri":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/"},{"categories":["编程"],"content":"go vet checking 上述两个例子都是在程序编译后，runtime检查的。但是，正如文中开篇所述，sync包下的其他的对象如Pool、WaitGroup、Mutex、Map等，它们其实也需要copy检查机制，但是在源码中，却没有提供运行时检查。那该如何保证我们的代码中这些对象在使用中未被copy，从而避免潜在的安全问题呢？ Go在源代码src/sync/cond.go中的一段注释给了我们答案。 // noCopy may be embedded into structs which must not be copied // after the first use. // // See https://golang.org/issues/8005#issuecomment-190753527 // for details. type noCopy struct{} // Lock is a no-op used by -copylocks checker from `go vet`. func (*noCopy) Lock() {} func (*noCopy) Unlock() {} 很明显，runtime时的copy检查虽然很重要，但是，该操作会影响程序的执行性能。Go官方目前只提供了strings.Builder和sync.Cond的runtime拷贝检查机制，对于其他需要nocopy对象类型来说，使用go vet工具来做静态编译检查。 具体实施来说，就是该对象，或对象中存在filed，它拥有Lock()和Unlock()方法，即实现sync.Locker接口。之后，可以通过go vet功能，来检查代码中该对象是否有被copy。 例如sync.Pool和sync.WaitGroup就内嵌了noCopy属性，sync.Mutex实现了sync.Locker接口，sync.Map内嵌了sync.Mutex。 静态检查 // wg.go package main import \"sync\" func main() { var sm sync.Mutex sm.Lock() sm.Unlock() sm2 := sm sm2.Lock() } 如上，sm在first use后，被copy给sm2。注意：该代码运行时，不会报错，但是却存在安全隐患。 $ go vet wg.go # command-line-arguments ./wg.go:9:9: assignment copies lock value to sm2: sync.Mutex 通过以上命令，即可检查出sync.Mutex有被copy。因此，举一反三，如果在我们自己的项目开发中，定义某对象不能被copy，那么就可以参考Go源码中，嵌入noCopy结构体，最终通过go vet进行copy检查。 type noCopy struct{} func (*noCopy) Lock() {} func (*noCopy) Unlock() {} type MyType struct { noCopy noCopy ... } ","date":"2021-02-11","objectID":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/:2:2","tags":["golang"],"title":"go的noCopy机制","uri":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/"},{"categories":["其他"],"content":"建立博客以来，试用了多款评论系统，不过最终还是用了 disqus，但是 disqus 令人讨厌的是默认添加很多烦人的广告，牛皮癣一样，而且在国内无法加载，必须翻墙才能显示。utterances 是一款基于 github issues 的评论系统，简洁，避免了 disqus 的广告以及加载问题。这篇文章总结如何给 LoveIt 主题添加 utterances 评论系统。 注：该主题已经支持了utterances，所以我们只需要简单配置就能使用，如果你使用的主题还不支持，需要按照文档进行代码嵌入 操作如下： 建立一个 public GitHub 仓库，这个仓库的 issue 用来存放博客评论：如果自己的博客就是用 GitHub pages 建立的，那么就不需要额外建立仓库了，就用博客的仓库也可以。例如我的博客放在 bychannel/bychannel.github.io这个仓库，就可以用这个仓库存放博客的评论。 安装 utterances 的 app：install 以后，在 Repository access，选择 Only select repositories，然后选择自己建立的用来存放评论的仓库即可。这时，进入到对应仓库的设置界面，点击 Integrations，会看到 utterances 的 app。 Hugo 对应的设置：主题已经支持了 utterances，在博客的 config.toml 配置文件，加入下面的配置： [params.page.comment.utterances] enable = true # owner/repo repo = \"bychannel/bychannel.github.io\" issueTerm = \"pathname\" label = \"comment\" lightTheme = \"github-light\" darkTheme = \"github-dark\" 重新 deploy Hugo 博客，等博客更新以后，utterances 评论系统即可生效。 要在博客文章下面评论，只需要登录自己的 GitHub 账号即可。 ","date":"2020-06-09","objectID":"/%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0utterances%E8%AF%84%E8%AE%BA/:0:0","tags":["blog"],"title":"博客添加utterances评论","uri":"/%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0utterances%E8%AF%84%E8%AE%BA/"},{"categories":["其他"],"content":"这里记录一下hugo静态博客的搭建过程，本文假设你已经了解hugo、github、github pages的相关知识，不清楚可以先去google了解一下。 我的方案主要分为以下几个核心部分： 个人博客源仓库，对博客配置及所有文章 .md 源文件进行版本管理，配合 GitHub Action 进行自动化部署，自动生成静态站点推送到 GitHub Pages 博客发布仓库。 GitHub Pages 博客发布仓库，以 username.github.io 形式命名的仓库，使用 GitHub Pages 实现网站部署，可以通过配置域名 CNAME 解析使用自定义域名。 Hugo 主题仓库，fork 喜欢的主题，并对自己的个人定制化改造配置进行版本管理，通过 git submodule 的方式链接到个人博客源仓库。 下文会对搭建、本地测试、自动化部署维护等过程进行详细讲解，希望对大家所有帮助。其他组件配置，如网站统计、评论系统等我们后面在慢慢补充。 ","date":"2020-06-07","objectID":"/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:0:0","tags":["blog"],"title":"自动化博客搭建记录","uri":"/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["其他"],"content":"博客源仓库 其实这个就是hugo的源工程，我们最终会把这个源工程提交到git仓库中进行版本管理，这样，我们的文章也就有版本了，见本站的源工程 前提 在此之前，你现在的环境中需要一下工具： hugo，最好是带extend的扩展版本，在编译主题中带有scss文件会用上，点此处 git，部署到github用到的工具，没有安装的话，直接下最新版本就好了 hugo工程 使用命令 hugo new site blog 就可以创建初始化一个hugo项目 主题 我们先点这里选择一个喜欢的主题，我的做法是fork了主题的github源码，自己如果有想法可以进行自定义修改，然后是把主题添加到hugo工程的themes目录下，这里建议使用子模块的方式进行添加： git submodule add https://github.com/bychannel/LoveIt themes/LoveIt 进入themes/LoveIt/exampleSite，这是主题的使用案例，可以直接复制config.toml文件覆盖hugo工程的配置，然后修改其中的参数，并参照exampleSite下的资源路径配置，文章路径，直接照搬使用即可，这样操作下来博客的雏形就好了。 新建文章 现在可以尝试写一篇测试文章看看，直接使用命令hugo new posts/test.md就能生成一篇新文章，文件路径在content/posts下，或者我们可以直接进入该路径下，复制一个markdown文章进行改写。 文章保存后，使用命令编译一下查看效果： hugo server -D 打开localhost:1313就能进行预览，如果效果不好，我们还可以修改markdown或者toml配置文件，并能够在浏览器实时查看修改后的效果。 ","date":"2020-06-07","objectID":"/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:0:1","tags":["blog"],"title":"自动化博客搭建记录","uri":"/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["其他"],"content":"pages仓库 每次使用hugo server命令进行编译，会在public目录下生成网站的静态资源，这些html、css等资源就是我们在浏览器中看到的页面了，我们需要单独把他发布出去。 创建仓库 GitHub Pages 项目需要符合 username.github.io 的特殊命名格式，仓库建立完成后，可以在设置中配置自己注册的自定义域名来指向 GitHub Pages 生成的网址。此外，需要将博客站点配置文件 config.toml 中的 baseURL 改为自己的自定义域名，这样博客站点才能正常访问 GitHub Pages 生成的网站服务。 域名配置 如果你购买了域名，不使用默认的username.github.io，那你需要在购买域名的后台系统进行域名重定向配置，这里我没有购买域名，就不再进行演示了，自己实操一下应该是没问题的。 自动发布 能自动化处理的事情，我们绝不手动处理，不仅仅是重复的劳动，更是因为手动更加容易出错。 因为我们的博客基于 GitHub 与 GitHub Pages，可以通过官方提供的 GitHub Action 进行 CI 自动发布，下面我会进行详细讲解。GitHub Action 是一个持续集成和持续交付(CI/CD) 平台，可用于自动执行构建、测试和部署管道，目前已经有很多开发好的工作流，可以通过简单的配置即可直接使用。 配置在仓库目录 .github/workflows 下，以 .yml 为后缀。我的 GitHub Action 配置，自动发布示例配置如下 name: deploy on: push: workflow_dispatch: schedule: # Runs everyday at 8:00 AM - cron: \"0 0 * * *\" jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \"latest\" extended: true - name: Build Web run: hugo - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: bychannel/bychannel.github.io PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} on 表示 GitHub Action 触发条件，我设置了 push、workflow_dispatch 和 schedule 三个条件： push，当这个项目仓库发生推送动作后，执行 GitHub Action workflow_dispatch，可以在 GitHub 项目仓库的 Action 工具栏进行手动调用 schedule，定时执行 GitHub Action，如我的设置为北京时间每天早上执行，主要是使用一些自动化统计 CI 来自动更新我博客的关于页面 jobs 表示 GitHub Action 中的任务，我们设置了一个 build 任务，runs-on 表示 GitHub Action 运行环境，我们选择了 ubuntu-latest。我们的 build 任务包含了 Checkout、Setup Hugo、Build Web 和 Deploy Web 四个主要步骤，其中 run 是执行的命令，uses 是 GitHub Action 中的一个插件，我们使用了 peaceiris/actions-hugo@v2 和 peaceiris/actions-gh-pages@v3 这两个插件。其中 Checkout 步骤中 with 中配置 submodules 值为 true 可以同步博客源仓库的子模块，即我们的主题模块。 大家可以根据自己的实际情况进行配置改写，然后加入到工程的对应路径下，github会按照配置自动执行。 token配置 因为我们需要从一个git仓库push到另一个git仓库，那么需要进行对应的token配置，以便推送的时候能正确的进行权限认证。 首先要在 GitHub 账户下 Setting - Developer setting - Personal access tokens - Tokens(classic) 下创建一个 Token。权限需要开启 repo 与 workflow，选择永不过期。 配置后复制生成的 Token（注：只会出现一次），然后在我们博客源仓库的 Settings - Secrets and variables - Actions 中，添加密钥 PERSONAL_TOKEN 为刚才的 Token，这样 GitHub Action 就可以获取到 Token 了。 完成上述配置后，推送代码至仓库，即可触发 GitHub Action，自动生成博客页面并推送至 GitHub Pages 仓库。 ","date":"2020-06-07","objectID":"/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:0:2","tags":["blog"],"title":"自动化博客搭建记录","uri":"/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["其他"],"content":"总结 以上就是我通过 Hugo 与 GitHub Action 实现的博客自动部署系统，我自己的实现仓库如下： 博客源码仓库 https://github.com/bychannel/blog， 主题仓库 https://github.com/bychannel/LoveIt ， 发布仓库 https://github.com/bychannel/bychannel.github.io 这样整理下来，我们不仅可以随时修改整个博客，而且流程全自动化，我们只需要专注于产出文章，然后提交到源仓库就可以了。 如果还有不清楚或者没讲明白的地方，大家可以下面评论区提出来讨论一下。 ","date":"2020-06-07","objectID":"/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:0:3","tags":["blog"],"title":"自动化博客搭建记录","uri":"/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"我是谁 花名池鱼，是当年加入小牛互娱时所取，选自陶渊明的《归园田居·其一》中的”羁鸟恋旧林，池鱼思故渊“，之所以选择”池鱼“作为花名，也是和作者有类型心境，不堪束缚，渴望自由。 一名手游后端开发者，目前已经在游戏行业混迹了快5年，在创业公司干过多面手，也在大公司当过螺丝钉，各种主流语言都会一点，目前专注golang。 ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"关于作者","uri":"/about/"},{"categories":null,"content":"关注方向 熬夜修过bug，通宵发过版，或许只有游戏人才能体会发版夜的漫长，咖啡槟榔也无法支撑起疲惫的眼皮。或许是行业红海的内卷，国家监管的出手，又或是大厂的垄断，经济的低迷，现如今纯游戏行业似乎不是那么好混了。对于非新手、非老手的我来说，有一点点尴尬，经过深思熟虑，也是对于新技术的追求，决定关注web3方面的技术，利用业余时间学习相关的新技术，也给自己在未来增加一些竞争力。 ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"关于作者","uri":"/about/"},{"categories":null,"content":"关于博客 最早开始写博客可以追溯到大一，到现在工作快五年了，也经历了差不多8年，很遗憾期间走走停停没能坚持下来，自己也总结了原因，最大的问题还是自己恒心不够，其他原因还有技术积淀不足，产出的文章内容不够充实。另外，博客写作平台也是一直在切换，从自建博客wordpress，到简书、csdn等平台，在写作体验上总有各种缺点，其实我个人非常喜欢简洁的写作体验，就好似代码编程一样。 现在博客是采用hugo静态编译markdown的方式，相对于之前的方案，优点如下： 写作方式：纯markdown编辑体验，本地编辑器写作，流程丝滑。 文章管理：等同于git仓库的md文件管理，随心所欲整理，git多版本管理。 部署流程：action自动化部署，提交自动走发布流程，丝滑到极致。 自定义：博客所有权都归自己，有点类似web3的思想，我的草原我的马，我想咋耍就咋耍。 …… 缺点也是有一些的，那就是需要一定的动手能力，但也不会太折腾，毕竟已经有很多前辈踩过坑了，致敬 👏 所以，希望自己能产出更多优质的内容，在这里遇到更多志同道合的朋友，大家一起技术进步!! ","date":"2019-08-02","objectID":"/about/:0:3","tags":null,"title":"关于作者","uri":"/about/"}]