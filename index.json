[{"categories":["编程"],"content":"在互联网服务中，特别是在云环境下，网络及硬件环境复杂，所有应用程序都可能遇到暂时性故障。暂时性故障包括瞬时的网络抖动，服务暂时不可用，服务繁忙导致超时等，这些故障通常可以自我修复，在间隔一定时间后重试，则很大概率可以成功。 ​ ","date":"2022-07-13","objectID":"/redis%E8%B6%85%E6%97%B6%E9%87%8D%E8%AF%95%E5%B0%8F%E7%BB%93/:0:0","tags":["redis"],"title":"redis超时重试小结","uri":"/redis%E8%B6%85%E6%97%B6%E9%87%8D%E8%AF%95%E5%B0%8F%E7%BB%93/"},{"categories":["编程"],"content":"为什么会出现暂时性故障 云 Redis 集群的高可用 云 Redis 集群或者云环境中的很多产品，都是由大量机器组成的集群提供服务，机器可能发生各种各样的硬件故障，比如 CPU，内存，磁盘 都可能发生故障。当故障发生时，Redis 服务会自动做 HA (High Available)，切换备用节点上来，客户端则可能遇到连接闪断，节点只读 （主动 HA 流程需要对主禁止写入，从而让数据完整同步到备）等暂时性故障。 ​ 客户已知的慢查询瞬间打满Redis 如果 Redis 在定期执行一些已知的慢查询，比如（keys, hgetall, smembers）等复杂度为 O(N) 的操作，则可能导致其余 O(1) 复杂度的 API 出现暂时性失败。 ​ 复杂的网络环境 云上网络环境复杂，客户端和服务器之间的网络状况会不时改变，偶现网络抖动，数据包重传等问题。 ","date":"2022-07-13","objectID":"/redis%E8%B6%85%E6%97%B6%E9%87%8D%E8%AF%95%E5%B0%8F%E7%BB%93/:0:1","tags":["redis"],"title":"redis超时重试小结","uri":"/redis%E8%B6%85%E6%97%B6%E9%87%8D%E8%AF%95%E5%B0%8F%E7%BB%93/"},{"categories":["编程"],"content":"重试的准则 适当的重试次数与间隔 必须优化重试次数与间隔。如果重试次数不足或者间隔太长，应用程序无法完成操作，并且可能失败。如果重试次数太多或者间隔太短，则可能会增大程序对系统资源的占用，且有可能造成服务端堆积太多请求无法恢复。确定适当的重试间隔是最困难的部分，常见的重试间隔如指数退让、增量间隔、固定间隔[1]等。 避免重试嵌套 大多数情况下，应该避免重试嵌套，嵌套容易造成反复重试且无法停止。 ​ 记录重试过程异常，但只有最终失败被报告 重试过程中，建议按照 WARN 级别打印重试的错误日志，但是只有最终重试失败时候才抛出 Exception，重试过程中如果能完成请求的正确访问，则不会打扰到用户。 ​ 超时之后不一定就可以重试 超时是一种未决现象，配置超时时间 2s，那么客户端通常的行为是当命令发送之后开始计时，如果在 2s 内没有成功收到回复，则客户端抛出 Timeout Exception。但此时服务端有没有执行过命令呢？是未决的，因为超时可能发生在任何阶段： 命令被客户端发出，但是还没有到达 Redis 命令到达 Redis，但是执行时候超时 命令执行结束，但是结果返回客户端时候超时 因此，对于有的命令，超时之后就不一定可以重试，是否可以重试的准则是命令执行是否幂等。 幂等操作才能重试 需要确定重试的操作是否为幂等的，例如： set a b，就是幂等的，多次执行最终 a 的值只可能为 b 或者失败。 lpush list a，就不是幂等的，如果多次 lpush list a，则 list 中可能包含多个 a 元素。 ","date":"2022-07-13","objectID":"/redis%E8%B6%85%E6%97%B6%E9%87%8D%E8%AF%95%E5%B0%8F%E7%BB%93/:0:2","tags":["redis"],"title":"redis超时重试小结","uri":"/redis%E8%B6%85%E6%97%B6%E9%87%8D%E8%AF%95%E5%B0%8F%E7%BB%93/"},{"categories":["编程"],"content":"Redis 常见客户端如何做重试 Redis 客户端开源生态繁荣，几乎各个编程语言都有对应的 Redis 客户端，Redis 官网（https://redis.io/clients）列出了很多 Redis 客户端，下面我们用go-redis客户端讨论如何做重试。 对于go-redis客户端来说，在Options中已经提供了超时的相关配置，我们只需要在调用NewClient方法时，传入我们创建好的Options结构即可，这样我们创建好的client就具备了超时重试的能力。 配置如下： // 最大重试次数 MaxRetries int // 重试间隔最小backoff值 MinRetryBackoff time.Duration // 重试间隔最大backoff值 MaxRetryBackoff time.Duration // 链接超时 DialTimeout time.Duration // 读超时 ReadTimeout time.Duration // 写超时 WriteTimeout time.Duration 默认的重试次数是3次，每次重试的时间间隔是根据backoff算法计算出来的，也就是上面配置的最大backoff和最小backoff两个配置，所有超时相关的重试机制，都是由上面三个配置决定的。 ","date":"2022-07-13","objectID":"/redis%E8%B6%85%E6%97%B6%E9%87%8D%E8%AF%95%E5%B0%8F%E7%BB%93/:0:3","tags":["redis"],"title":"redis超时重试小结","uri":"/redis%E8%B6%85%E6%97%B6%E9%87%8D%E8%AF%95%E5%B0%8F%E7%BB%93/"},{"categories":["编程"],"content":"总结 本文总结了 Redis 导致超时的一些原因，为什么需要做重试，以及重试应当遵循的准则。并举例了go-redis客户端如何做重试。 ","date":"2022-07-13","objectID":"/redis%E8%B6%85%E6%97%B6%E9%87%8D%E8%AF%95%E5%B0%8F%E7%BB%93/:1:0","tags":["redis"],"title":"redis超时重试小结","uri":"/redis%E8%B6%85%E6%97%B6%E9%87%8D%E8%AF%95%E5%B0%8F%E7%BB%93/"},{"categories":["编程"],"content":" 注：本文转载自 https://www.jianshu.com/p/a010f55ac805 如有侵权，联系删除 游戏服务器不管是个人的还是企业的，被攻击都是，很常见的，在所难免的。特别是游戏新上线时，都要承受的住哪些外来压力，玩家突然猛增，被攻击等等。如果承受不住可能会直接宣布游戏倒闭。这里我们一起来说说游戏服务器为什么老被攻击的一些原因和怎么防御游戏服务器。 游戏服务器常见的几种攻击 被DDOS攻击： DDoS攻击运用服务器技能将多台计算机联合起来，一起向一个或是多个方针游戏服务器发送DDoS进犯，以提高进犯游戏服务器的威力。游戏服务器在被进犯的时候会占用消耗掉服务器的资源，严峻直接导致游戏服务器瘫痪，使得游戏服务器没办法正常运转。 被CC攻击： CC攻击是攻击者控制某些主机不停地发大量数据包给对方游戏服务器造成服务器资源耗尽，一直到宕机崩溃。CC攻击能够让你见不到真实源IP，见不到特别大的异常流量，但却能造成服务器无法进行正常连接。而且这种攻击技术含量低，是很多攻击者最常使用的一种攻击手法。 被SYN攻击： SYN攻击主要是利用TCP协议缺陷，通过发送大量的半连接请求，耗费对方游戏服务器的CPU和内存资源，使其游戏网站运行缓慢，严重者引起网络堵塞甚至系统瘫痪。SYN攻击实现起来非常的简单，不管目标是什么系统，只要这些系统打开TCP服务就可以实施。SYN攻击除了能影响主机外，还可以危害路由器、防火墙等网络系统。 游戏服务器被攻击了如何防御 1、确保服务器系统安全 管理员需对所有主机进行检查，知道访问者的来源，查看网络设备和主机/服务器系统的日志，并且使用工具来过滤不必要的服务和端口，限制同时打开的SYN半连接数目，确保服务器的系统文件是最新的版本,并及时更新系统补丁。 2、在骨干节点配置防火墙 防火墙本身能抵御DDoS攻击和其他一些攻击。在发现游戏服务器受到攻击的时候，可以将攻击导向一些牺牲主机，这样可以保护真正的主机不被攻击。 3、使用CDN加速服务 高防CDN加速具有防御各种攻击的功能，因此要解决游戏网站安全添加CDN加速是不可缺少的。CDN加速不仅对游戏网站进行了加速，同时可以将所有的域名和子域都使用CDN来解析，隐藏真实IP地址，保护网站安全。 4、购买第三方防御 高防服务器是游戏里相当火爆的防御DDoS的方式之一，价格便宜，是此种方式最重要的优势。客户可以在凌晨完成服务器的数据迁移，这样能将损失降到最小，先选择较低的防御机器，后期攻击高了，直接一键升级防御，比较方便。 ","date":"2022-06-23","objectID":"/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E5%92%8C%E9%98%B2%E5%BE%A1/:0:0","tags":["服务器","安全"],"title":"【转载】服务器常见攻击方式和防御","uri":"/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E5%92%8C%E9%98%B2%E5%BE%A1/"},{"categories":["编程"],"content":"nil 是 Go 语言中经常使用的标识符，语义上代表了很多类型的零值。相信很多 Gopher 在实际使用中都或多或少踩过 nil 的坑，比如 interface 中 nil 的含义。这篇文章希望梳理一下nil 的用法和原理。 这是 buildin/buildin.go 中对于 nil 的定义 // nil is a predeclared identifier representing the zero value for a // pointer, channel, func, interface, map, or slice type. var nil Type // Type must be a pointer, channel, func, interface, map, or slice type ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:0","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"nil 是Go语言内预置的标识符 这意味着你可以直接使用，无需额外声明。 ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:1","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"nil 是很多类型的零值 指针 Map Slice Function Channel Interface ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:2","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"nil 无默认类型 这一点非常重要，目前除了nil以外，所有的Go语言预置标识符都有一个默认类型，如 iota 的默认类型为 int。但nil 是个例外，预置的 nil 是唯一一个无默认类型的值。编译器需要足够的信息来判断一个 nil 值对应的类型。 如下代码可以通过编译： _ = (*struct{})(nil) _ = []int(nil) _ = map[int]bool(nil) _ = chan string(nil) _ = (func())(nil) _ = interface{}(nil) // 等价于 var _ *struct{} = nil var _ []int = nil var _ map[int]bool = nil var _ chan string = nil var _ func() = nil var _ interface{} = nil 下方的代码无法通过编译： var _ = nil ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:3","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"nil 并非 Go 语言的关键字 你会发现，类似下面的代码是可以通过编译的： package main import \"fmt\" func main() { nil := 123 fmt.Println(nil) // 123 } 此时 nil 已经被覆盖，并非是原来的语义，变成了一个 int 类型，值为 123的变量。若在此变量范围中继续使用 nil ，将会一直维持这个语义。 ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:4","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"nil 所占内存大小随着类型变化而变化 某个类型下所有的变量都有同样的内存结构，nil 也不例外。 package main import ( \"fmt\" \"unsafe\" ) func main() { var p *struct{} = nil fmt.Println( unsafe.Sizeof( p ) ) // 8 var s []int = nil fmt.Println( unsafe.Sizeof( s ) ) // 24 var m map[int]bool = nil fmt.Println( unsafe.Sizeof( m ) ) // 8 var c chan string = nil fmt.Println( unsafe.Sizeof( c ) ) // 8 var f func() = nil fmt.Println( unsafe.Sizeof( f ) ) // 8 var i interface{} = nil fmt.Println( unsafe.Sizeof( i ) ) // 16 } 需要注意的是，上面打印出的大小可能随着运行环境和编译器变化而改变。 ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:5","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"两个 nil 值未必相等 先来看这段代码： package main import \"fmt\" type SomeStruct struct{} func main() { var h *SomeStruct var wrapper interface{} = h fmt.Println(h == nil, wrapper == nil) // true, false } 这其实是日常 Go 开发中经常遇到的坑，h == nil 返回 true 很好理解，但为什么只是用 interface 包装了一层，就不再 == nil 了呢？ non-interface value will be converted to the type of the interface value before making the comparison. 前面我们提到过，Go预置的 nil 是没有类型的，为了让 wrapper 和 nil 进行比较，编译器会首先将 nil 转化为一个 interface{}，然后进行比较。但是注意，因为 nil 无默认类型，即便转为 interface{}，它也是没有对应的动态类型的，跟 wrapper 的动态类型*SomeStruct 不匹配，所以会返回 false。 结论：一个接口包括动态类型和动态值。如果一个接口的动态类型和动态值都为空，则这个接口为空的。如果两个被比较的 nil 值，一个是interface{}，另一个不是，那么即便可以通过编译，比较结果永远是false。 这样就可以理解，为什么下面的比较结果是 false fmt.Println( (interface{})(nil) == (*int)(nil) ) // false ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:6","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"interface 底层结构 根据 interface 是否包含有 method，底层实现上用两种 struct 来表示：iface 和 eface。eface表示不含 method 的 interface 结构，或者叫 empty interface。 eface type eface struct { _type *_type data unsafe.Pointer } type _type struct { size uintptr // type size ptrdata uintptr // size of memory prefix holding all pointers hash uint32 // hash of type; avoids computation in hash tables tflag tflag // extra type information flags align uint8 // alignment of variable with this type fieldalign uint8 // alignment of struct field with this type kind uint8 // enumeration for C alg *typeAlg // algorithm table gcdata *byte // garbage collection data str nameOff // string form ptrToThis typeOff // type for pointer to this type, may be zero } iface iface 表示 non-empty interface 的底层实现。相比于 empty interface，non-empty 要包含一些 method。method 的具体实现存放在 itab.fun 变量里。如果 interface 包含多个 method，这里只有一个 fun 变量怎么存呢？这个下面再细说。 type iface struct { tab *itab data unsafe.Pointer } // layout of Itab known to compilers // allocated in non-garbage-collected memory // Needs to be in sync with // ../cmd/compile/internal/gc/reflect.go:/^func.dumptypestructs. type itab struct { inter *interfacetype _type *_type link *itab bad int32 inhash int32 // has this itab been added to hash? fun [1]uintptr // variable sized } 概括起来，接口对象由接口表 (interface table) 指针和数据指针组成，或者说由动态类型和动态值组成。 接口表存储元数据信息，包括接口类型、动态类型，以及实现接口的方法指针。无论是反射还是通过接口调用方法，都会用到这些信息。 ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:7","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"怎么解决 interface 和 nil 的比较 上一节我们得出了结论 如果两个被比较的 nil 值，一个是interface{}，另一个不是，那么即便可以通过编译，比较结果永远是false。 但实际应用场景中，依然有 interface 和 nil 比较的诉求，很多时候我们不希望在意类型，只是希望明确当前这个 interface 动态值，是否为零值。用==显然是无法做到这一点。 这个时候我们可以借助反射的帮助来实现。 在 Golang relfect 包的文档中我们可以看到 // IsNil reports whether its argument v is nil. // The argument must be a chan, func, interface, map, pointer, or slice value; if it is not, IsNil panics. // Note that IsNil is not always equivalent to a regular comparison with nil in Go. For example, if v was created by calling ValueOf with an uninitialized interface variable i, i==nil will be true but v.IsNil will panic as v will be the zero Value. func (v Value) IsNil() bool 先将 interface 值转化为 reflect.Value，然后借用IsNil 来判断是否为空即可。 示例代码： func isNil(i interface{}) bool { return i == nil || reflect.ValueOf(i).IsNil() } 但事实上，使用reflect包下的方法一定要小心，此处入参 i 的类型为 interface{}，也就意味着任何类型的值传进来皆可，贸然使用反射，容易引发 panic。 如果 i 是一个普通的结构体，非指针类型。此处IsNil会直接抛panic，注意文档注释。 The argument must be a chan, func, interface, map, pointer, or slice value; if it is not, IsNil panics 所以，修改代码逻辑如下： func isNilFixed(i interface{}) bool { if i == nil { return true } switch reflect.TypeOf(i).Kind() { case reflect.Ptr, reflect.Map, reflect.Array, reflect.Chan, reflect.Slice: return reflect.ValueOf(i).IsNil() } return false } ","date":"2022-06-07","objectID":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/:0:8","tags":["golang"],"title":"go的nil用法","uri":"/go%E7%9A%84nil%E7%94%A8%E6%B3%95/"},{"categories":["编程"],"content":"主从复制模式 ","date":"2022-05-03","objectID":"/redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/:1:0","tags":["redis","集群"],"title":"redis的三种集群方案","uri":"/redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"主从复制的作用 通过持久化功能，Redis保证了即使在服务器重启的情况下也不会丢失（或少量丢失）数据，因为持久化会把内存中数据保存到硬盘上，重启会从硬盘上加载数据。 但是由于数据是存储在一台服务器上的，如果这台服务器出现硬盘故障等问题，也会导致数据丢失。 为了避免单点故障，通常的做法是将数据库复制多个副本以部署在不同的服务器上，这样即使有一台服务器出现故障，其他服务器依然可以继续提供服务。 为此， Redis 提供了复制（replication）功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上。 在复制的概念中，数据库分为两类，一类是主数据库（master），另一类是从数据库(slave）。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。 总结：引入主从复制机制的目的有两个 一个是读写分离，分担 “master” 的读写压力 一个是方便做容灾恢复 ","date":"2022-05-03","objectID":"/redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/:1:1","tags":["redis","集群"],"title":"redis的三种集群方案","uri":"/redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"主从复制原理 从数据库启动成功后，连接主数据库，发送 SYNC 命令； 主数据库接收到 SYNC 命令后，开始执行 BGSAVE 命令生成 RDB 文件并使用缓冲区记录此后执行的所有写命令； 主数据库 BGSAVE 执行完后，向所有从数据库发送快照文件，并在发送期间继续记录被执行的写命令； 从数据库收到快照文件后丢弃所有旧数据，载入收到的快照； 主数据库快照发送完毕后开始向从数据库发送缓冲区中的写命令； 从数据库完成对快照的载入，开始接收命令请求，并执行来自主数据库缓冲区的写命令；（从数据库初始化完成） 主数据库每执行一个写命令就会向从数据库发送相同的写命令，从数据库接收并执行收到的写命令（从数据库初始化完成后的操作） 出现断开重连后，2.8之后的版本会将断线期间的命令传给重数据库，增量复制。 主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。Redis 的策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。 ","date":"2022-05-03","objectID":"/redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/:1:2","tags":["redis","集群"],"title":"redis的三种集群方案","uri":"/redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"主从复制优缺点 主从复制优点 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离； 为了分载 Master 的读操作压力，Slave 服务器可以为客户端提供只读操作的服务，写服务仍然必须由Master来完成； Slave 同样可以接受其它 Slaves 的连接和同步请求，这样可以有效的分载 Master 的同步压力； Master Server 是以非阻塞的方式为 Slaves 提供服务。所以在 Master-Slave 同步期间，客户端仍然可以提交查询或修改请求； Slave Server 同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis则返回同步之前的数据； 主从复制缺点 Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复（也就是要人工介入）； 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性； 如果多个 Slave 断线了，需要重启的时候，尽量不要在同一时间段进行重启。因为只要 Slave 启动，就会发送sync 请求和主机全量同步，当多个 Slave 重启的时候，可能会导致 Master IO 剧增从而宕机。 Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂； ","date":"2022-05-03","objectID":"/redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/:1:3","tags":["redis","集群"],"title":"redis的三种集群方案","uri":"/redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"Sentinel（哨兵）模式 第一种主从同步/复制的模式，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。 哨兵模式是一种特殊的模式，首先 Redis 提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个 Redis 实例。 单哨兵 ","date":"2022-05-03","objectID":"/redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/:2:0","tags":["redis","集群"],"title":"redis的三种集群方案","uri":"/redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"哨兵模式的作用 通过发送命令，让 Redis 服务器返回监控其运行状态，包括主服务器和从服务器； 当哨兵监测到 master 宕机，会自动将 slave 切换成 master ，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机； 然而一个哨兵进程对Redis服务器进行监控，也可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。 多哨兵 ","date":"2022-05-03","objectID":"/redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/:2:1","tags":["redis","集群"],"title":"redis的三种集群方案","uri":"/redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"故障切换的过程 假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行 failover 过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行 failover 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。这样对于客户端而言，一切都是透明的。 ","date":"2022-05-03","objectID":"/redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/:2:2","tags":["redis","集群"],"title":"redis的三种集群方案","uri":"/redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"哨兵模式的工作方式 每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的 Master 主服务器，Slave 从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。 如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN） 如果一个 Master 主服务器被标记为主观下线（SDOWN），则正在监视这个 Master 主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认 Master 主服务器的确进入了主观下线状态 当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认 Master 主服务器进入了主观下线状态（SDOWN）， 则 Master 主服务器会被标记为客观下线（ODOWN） 在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有 Master 主服务器、Slave 从服务器发送 INFO 命令。 当 Master 主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master 主服务器的所有 Slave 从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。 若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master 主服务器的客观下线状态就会被移除。若 Master 主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。 ","date":"2022-05-03","objectID":"/redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/:2:3","tags":["redis","集群"],"title":"redis的三种集群方案","uri":"/redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"哨兵模式的优缺点 优点： 哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。 主从可以自动切换，系统更健壮，可用性更高(可以看作自动版的主从复制)。 缺点： Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。 ","date":"2022-05-03","objectID":"/redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/:2:4","tags":["redis","集群"],"title":"redis的三种集群方案","uri":"/redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"Cluster 集群模式（Redis官方） Redis Cluster是一种服务器 Sharding 技术，3.0版本开始正式提供。 Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，所以在 redis3.0上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，也就是说每台 Redis 节点上存储不同的内容。 image-20200531184321294 在这个图中，每一个蓝色的圈都代表着一个 redis 的服务器节点。它们任何两个节点之间都是相互连通的。客户端可以与任何一个节点相连接，然后就可以访问集群中的任何一个节点。对其进行存取和其他操作。 ","date":"2022-05-03","objectID":"/redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/:3:0","tags":["redis","集群"],"title":"redis的三种集群方案","uri":"/redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"集群的数据分片 Redis 集群没有使用一致性 hash，而是引入了哈希槽【hash slot】的概念。 Redis 集群有16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽。集群的每个节点负责一部分hash槽，举个例子，比如当前集群有3个节点，那么： 节点 A 包含 0 到 5460 号哈希槽 节点 B 包含 5461 到 10922 号哈希槽 节点 C 包含 10923 到 16383 号哈希槽 这种结构很容易添加或者删除节点。比如如果我想新添加个节点 D ， 我需要从节点 A， B， C 中得部分槽到 D 上。如果我想移除节点 A ，需要将 A 中的槽移到 B 和 C 节点上，然后将没有任何槽的 A 节点从集群中移除即可。由于从一个节点将哈希槽移动到另一个节点并不会停止服务，所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态。 在 Redis 的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383。还有一个就是 cluster，可以理解为是一个集群管理的插件。当我们的存取的 Key到达的时候，Redis 会根据 CRC16 的算法得出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。 ","date":"2022-05-03","objectID":"/redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/:3:1","tags":["redis","集群"],"title":"redis的三种集群方案","uri":"/redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"Redis 集群的主从复制模型 为了保证高可用，redis-cluster集群引入了主从复制模型，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。当其它主节点 ping 一个主节点 A 时，如果半数以上的主节点与 A 通信超时，那么认为主节点 A 宕机了。如果主节点 A 和它的从节点 A1 都宕机了，那么该集群就无法再提供服务了。 ","date":"2022-05-03","objectID":"/redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/:3:2","tags":["redis","集群"],"title":"redis的三种集群方案","uri":"/redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"集群的特点 所有的 redis 节点彼此互联(PING-PONG机制)，内部使用二进制协议优化传输速度和带宽。 节点的 fail 是通过集群中超过半数的节点检测失效时才生效。 客户端与 Redis 节点直连，不需要中间代理层.客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。 ","date":"2022-05-03","objectID":"/redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/:3:3","tags":["redis","集群"],"title":"redis的三种集群方案","uri":"/redis%E7%9A%84%E4%B8%89%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"Go 的设计是一种简单哲学，它摒弃了其他语言一些臃肿的功能和模块，以降低程序员的学习门槛，减少使用中的心智负担。 本文，我们来探讨 Go 中缺失的数据结构：Set，以及它的最佳实现方案。 ","date":"2022-04-15","objectID":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/:0:0","tags":["golang","数据结构"],"title":"go的set实现方案","uri":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"Set 语义与实现方案 Set 集合是其他语言中常见的数据结构。特性：集合中的对象不按特定的方式排序，并且没有重复对象。 学习 Go ，要记住：Go 没有包含的东西，不代表 Go 真的没有。根据 Set 特性，我们可以很轻松地想到使用 map 的实现方案（因为 map 的 key 是不重复的）：把对象当做 key 存入 map。 使用 map 来实现 Set，意味着我们只关心 key 的存在，其 value 值并不重要。有其他语言编程经验的人也许会选择 bool 来作为 value，因为它是其它语言中内存消耗最少的类型（1个字节）。但是在 Go 中，还有另一种选择：struct{}。 fmt.Println(unsafe.Sizeof(struct {}{})) // output: 0 ","date":"2022-04-15","objectID":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/:1:0","tags":["golang","数据结构"],"title":"go的set实现方案","uri":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"压测对比 为了探究哪种数据结构是作为 value 的最佳选择。我们选择了以下常用的类型作为 value 进行测试：bool、int、interface{}、struct{}。 package main import ( \"testing\" ) const num = int(1 \u003c\u003c 24) // 测试 bool 类型 func Benchmark_SetWithBoolValueWrite(b *testing.B) { set := make(map[int]bool) for i := 0; i \u003c num; i++ { set[i] = true } } // 测试 interface{} 类型 func Benchmark_SetWithInterfaceValueWrite(b *testing.B) { set := make(map[int]interface{}) for i := 0; i \u003c num; i++ { set[i] = struct{}{} } } // 测试 int 类型 func Benchmark_SetWithIntValueWrite(b *testing.B) { set := make(map[int]int) for i := 0; i \u003c num; i++ { set[i] = 0 } } // 测试 struct{} 类型 func Benchmark_SetWithStructValueWrite(b *testing.B) { set := make(map[int]struct{}) for i := 0; i \u003c num; i++ { set[i] = struct{}{} } } 我们运行以下命令，进行测试 $ go test -v -bench=. -count=3 -benchmem | tee result.txt goos: darwin goarch: amd64 pkg: workspace/example/demoForSet cpu: Intel(R) Core(TM) i5-8279U CPU @ 2.40GHz Benchmark_SetWithBoolValueWrite Benchmark_SetWithBoolValueWrite-8 1 3549312568 ns/op 883610264 B/op 614311 allocs/op Benchmark_SetWithBoolValueWrite-8 1 3288521519 ns/op 883599440 B/op 614206 allocs/op Benchmark_SetWithBoolValueWrite-8 1 3264097496 ns/op 883578624 B/op 614003 allocs/op Benchmark_SetWithInterfaceValueWrite Benchmark_SetWithInterfaceValueWrite-8 1 4397757645 ns/op 1981619632 B/op 614062 allocs/op Benchmark_SetWithInterfaceValueWrite-8 1 4088301215 ns/op 1981553392 B/op 613743 allocs/op Benchmark_SetWithInterfaceValueWrite-8 1 3990698218 ns/op 1981560880 B/op 613773 allocs/op Benchmark_SetWithIntValueWrite Benchmark_SetWithIntValueWrite-8 1 3472910194 ns/op 1412326480 B/op 615131 allocs/op Benchmark_SetWithIntValueWrite-8 1 3519755137 ns/op 1412187928 B/op 614294 allocs/op Benchmark_SetWithIntValueWrite-8 1 3459182691 ns/op 1412057672 B/op 613390 allocs/op Benchmark_SetWithStructValueWrite Benchmark_SetWithStructValueWrite-8 1 3126746088 ns/op 802452368 B/op 614127 allocs/op Benchmark_SetWithStructValueWrite-8 1 3161650835 ns/op 802431240 B/op 613632 allocs/op Benchmark_SetWithStructValueWrite-8 1 3160410871 ns/op 802440552 B/op 613748 allocs/op PASS ok workspace/example/demoForSet 42.660s 此时的结果看起来不太直观，这里推荐一个 benchmark 统计工具：Benchstat。通过以下命令进行安装 $ go get -u golang.org/x/perf/cmd/benchstat 使用 benchstat 分析刚才得到的 benchmark 结果文件 $ benchstat result.txt name time/op _SetWithBoolValueWrite-8 3.37s ± 5% _SetWithInterfaceValueWrite-8 4.16s ± 6% _SetWithIntValueWrite-8 3.48s ± 1% _SetWithStructValueWrite-8 3.15s ± 1% name alloc/op _SetWithBoolValueWrite-8 884MB ± 0% _SetWithInterfaceValueWrite-8 1.98GB ± 0% _SetWithIntValueWrite-8 1.41GB ± 0% _SetWithStructValueWrite-8 802MB ± 0% name allocs/op _SetWithBoolValueWrite-8 614k ± 0% _SetWithInterfaceValueWrite-8 614k ± 0% _SetWithIntValueWrite-8 614k ± 0% _SetWithStructValueWrite-8 614k ± 0% 从内存开销而言，struct{} 是最小的，反映在执行时间上也是最少的。由于 bool 类型仅占一个字节，它相较于空结构而言，相差的并不多。但是，如果使用 interface{} 类型，那差距就很明显了。 所以，毫无疑问，在 Set 的实现中， map 值类型应该选 struct{}。 ","date":"2022-04-15","objectID":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/:2:0","tags":["golang","数据结构"],"title":"go的set实现方案","uri":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"总结 本文虽然讨论的是 Set 的实现方案，但本质是涉及空结构体 struct{}{} 的 零内存特性。 空结构体除了是实现 Set 的 value 值最佳方案，它还可以应用于以下方面： 通知信号的 channel：当 channel 只用于通知 goroutine 的执行事件，此时 channel 就不需要发送任何实质性的数据，选择使用 chan struct{} 。 没有状态数据的结构体：当对象只拥有方法，而不包含任何的属性字段时，选择使用空结构体定义该对象。 ","date":"2022-04-15","objectID":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/:3:0","tags":["golang","数据结构"],"title":"go的set实现方案","uri":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"前言 golang是一门极具设计哲学的语言，其中一点是没有支持包循环导入，目的是迫使 Go 程序员更多地考虑程序的依赖关系。一方面保持依赖关系图的简洁，二是快速的程序构建。 通常来说，只要你的包规划得好，严格规范单向调用链（如控制层-\u003e业务层-\u003e数据层），一般不会出现包循环引用问题。当然现实业务往往不会这么理想，同层级之间的不同包经常需要互相引用，下面我就分享几种解决包循环引用的方案。 ","date":"2022-04-04","objectID":"/go%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/:0:1","tags":["golang"],"title":"go循环引用优化思路","uri":"/go%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/"},{"categories":["编程"],"content":"抽象接口 package_i package package_i type PackageAInterface interface { PrintA() } type PackageBInterface interface { PrintB() } package_a package package_a import ( \"cycle/package_i\" \"fmt\" ) type PackageA struct { B package_i.PackageBInterface } func (a PackageA) PrintA() { fmt.Println(\"I'm a!\") } func (a PackageA) PrintAll() { a.PrintA() a.B.PrintB() } package_b package package_b import ( \"cycle/package_i\" \"fmt\" ) type PackageB struct { A package_i.PackageAInterface } func (b PackageB) PrintB() { fmt.Println(\"I'm b!\") } func (b PackageB) PrintAll() { b.PrintB() b.A.PrintA() } main package main import ( \"cycle/package_a\" \"cycle/package_b\" ) func main() { a := new(package_a.PackageA) b := new(package_b.PackageB) a.B = b b.A = a a.PrintAll() b.PrintAll() } ","date":"2022-04-04","objectID":"/go%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/:0:2","tags":["golang"],"title":"go循环引用优化思路","uri":"/go%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/"},{"categories":["编程"],"content":"三、新建公共组合包（子包），在组合包中组合调用 package_c package package_c import ( \"cycle/package_a\" \"cycle/package_b\" ) type CombileAB struct { A *package_a.PackageA B *package_b.PackageB } func (c CombileAB) PrintAll() { c.A.PrintA() c.B.PrintB() } main package main import ( \"cycle/package_a\" \"cycle/package_b\" \"cycle/package_c\" ) func main() { a := new(package_a.PackageA) b := new(package_b.PackageB) c := new(package_c.CombileAB) c.A = a c.B = b c.PrintAll() } ","date":"2022-04-04","objectID":"/go%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/:1:0","tags":["golang"],"title":"go循环引用优化思路","uri":"/go%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/"},{"categories":["编程"],"content":"四、全局存储需要相互依赖的函数，通过关键字进行调用 callback_mgr package callback_mgr import ( \"fmt\" \"reflect\" ) var callBackMap map[string]interface{} func init() { callBackMap = make(map[string]interface{}) } func RegisterCallBack(key string, callBack interface{}) { callBackMap[key] = callBack } func CallBackFunc(key string, args ...interface{}) []interface{} { if callBack, ok := callBackMap[key]; ok { in := make([]reflect.Value, len(args)) for i, arg := range args { in[i] = reflect.ValueOf(arg) } outList := reflect.ValueOf(callBack).Call(in) result := make([]interface{}, len(outList)) for i, out := range outList { result[i] = out.Interface() } return result } else { panic(fmt.Errorf(\"callBack(%s) not found\", key)) } } package_a package package_a import ( \"cycle/callback_mgr\" \"fmt\" ) func init() { callback_mgr.RegisterCallBack(\"getA\", new(PackageA).GetA) } type PackageA struct { } func (a PackageA) GetA() string { return \"I'm a!\" } func (a PackageA) PrintAll() { fmt.Println(a.GetA()) fmt.Println(callback_mgr.CallBackFunc(\"getB\")[0].(string)) } package_b package package_b import ( \"cycle/callback_mgr\" \"fmt\" ) func init() { callback_mgr.RegisterCallBack(\"getB\", new(PackageB).GetB) } type PackageB struct { } func (b PackageB) GetB() string { return \"I'm b!\" } func (b PackageB) PrintAll() { fmt.Println(b.GetB()) fmt.Println(callback_mgr.CallBackFunc(\"getA\")[0].(string)) } main package main import ( \"cycle/package_a\" \"cycle/package_b\" ) func main() { a := new(package_a.PackageA) b := new(package_b.PackageB) a.PrintAll() b.PrintAll() } ","date":"2022-04-04","objectID":"/go%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/:2:0","tags":["golang"],"title":"go循环引用优化思路","uri":"/go%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/"},{"categories":["编程"],"content":"异步调用解耦 对于不需要执行结果的方法调用，可以采用事件总线进行异步调用。 eventBus package eventBus import ( \"github.com/asaskevich/EventBus\" ) var globalEventBus EventBus.Bus func init() { globalEventBus = EventBus.New() } func Subscribe(topic string, fn interface{}) error { return globalEventBus.Subscribe(topic, fn) } func SubscribeAsync(topic string, fn interface{}, transactional bool) error { return globalEventBus.SubscribeAsync(topic, fn, transactional) } func Publish(topic string, args ...interface{}) { globalEventBus.Publish(topic, args...) } package_a package package_a import ( \"cycle/eventBus\" \"fmt\" ) func init() { eventBus.Subscribe(\"PrintA\", new(PackageA).PrintA) } type PackageA struct { } func (a PackageA) PrintA() { fmt.Println(\"I'm a!\") } func (a PackageA) PrintAll() { a.PrintA() eventBus.Publish(\"PrintB\") } package_b package package_b import ( \"cycle/eventBus\" \"fmt\" ) func init() { eventBus.Subscribe(\"PrintB\", new(PackageB).PrintB) } type PackageB struct { } func (b PackageB) PrintB() { fmt.Println(\"I'm b!\") } func (b PackageB) PrintAll() { b.PrintB() eventBus.Publish(\"PrintA\") } ","date":"2022-04-04","objectID":"/go%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/:2:1","tags":["golang"],"title":"go循环引用优化思路","uri":"/go%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/"},{"categories":["kubernetes"],"content":"k8s作为目前容器化管理和编排最热门的项目，我们无疑需要马上去学习它，而实践是能够帮助我们快速入门一项技术，在实践的过程中，我们可以理解大致的使用，了解相关的概念，并在过程中遇到大量的问题，从而不断的深入去了解k8s，废话少说，下面我们通过如下几步，可以将自己的go应用部署到k8s上。 ","date":"2022-02-12","objectID":"/k8s%E9%83%A8%E7%BD%B2go%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/:0:0","tags":["k8s","集群部署"],"title":"k8s部署go应用入门实践","uri":"/k8s%E9%83%A8%E7%BD%B2go%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/"},{"categories":["kubernetes"],"content":"准备go项目 需要先准备一个go的项目，用于部署到k8s中，然后我们再对项目进行访问，从而对部署结果进行验证。如果自己已经有可以使用的项目了，可以直接使用自己的项目，我用gin创建了一个简单的演示项目，大家自取。 该项目提供了两个访问接口： / 用于返回固定的hello /test 用于返回当前的时间 ","date":"2022-02-12","objectID":"/k8s%E9%83%A8%E7%BD%B2go%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/:1:0","tags":["k8s","集群部署"],"title":"k8s部署go应用入门实践","uri":"/k8s%E9%83%A8%E7%BD%B2go%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/"},{"categories":["kubernetes"],"content":"编译镜像 接下来，编写Dockerfile将项目编译成一个docker image，内容如下 FROM golang:1.19.1-alpine as builder ENV GOPROXY=https://goproxy.cn WORKDIR /build COPY . . RUN go mod tidy RUN go build -o helloGin main.go FROM alpine:latest RUN mkdir -p /cmd WORKDIR /cmd COPY --from=builder /build . EXPOSE 8888 CMD [\"./helloGin\"] 生成镜像，执行命令 docker build -t hellogin:1.0.0 -f Dockerfile . 执行 docker images 可以看到生成的hellogin:1.0.0镜像已经存在了 ","date":"2022-02-12","objectID":"/k8s%E9%83%A8%E7%BD%B2go%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/:2:0","tags":["k8s","集群部署"],"title":"k8s部署go应用入门实践","uri":"/k8s%E9%83%A8%E7%BD%B2go%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/"},{"categories":["kubernetes"],"content":"推送镜像 因为k8s集群的pod在启动的时候，需要先拉取到目标镜像，所以需要把自己的镜像推到镜像服务器，我这里选用阿里的容器镜像服务个人版。自己进行开通此处不再展开，或者使用其他的镜像服务都可以，不影响后续操作。 先登陆-\u003e将自己生成的镜像打tag-\u003e推到镜像服务器 $ docker login --username=阿里云账户 registry.cn-shanghai.aliyuncs.com $ docker tag hellogin:1.0.0 registry.cn-shanghai.aliyuncs.com/命名空间/hellogin:1.0.0 $ docker push registry.cn-shanghai.aliyuncs.com/命名空间/hellogin:1.0.0 ","date":"2022-02-12","objectID":"/k8s%E9%83%A8%E7%BD%B2go%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/:3:0","tags":["k8s","集群部署"],"title":"k8s部署go应用入门实践","uri":"/k8s%E9%83%A8%E7%BD%B2go%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/"},{"categories":["kubernetes"],"content":"编写部署配置yaml 编写deployment和service配置文件，用于将image镜像如何部署到k8s中。 deployment.yaml文件内容如下： apiVersion: apps/v1 kind: Deployment metadata: name: hellogin spec: replicas: 3 # 启动3个pod selector: matchLabels: app: hello-gin template: metadata: labels: app: hello-gin spec: containers: - name: go-app-container image: registry.cn-shanghai.aliyuncs.com/bysimon/hellogin:1.0.0 imagePullPolicy: IfNotPresent resources: limits: memory: \"512Mi\" cpu: \"500m\" requests: memory: \"64Mi\" cpu: \"100m\" ports: - containerPort: 8888 # 程序端口 imagePullSecrets: - name: aliyun-registry # aliyun镜像拉取的秘钥 service.yaml内容如下 apiVersion: v1 kind: Service metadata: name: hellogin-service spec: type: NodePort ports: - port: 8888 nodePort: 30088 selector: app: hello-gin 需要对外提供服务所以type选NodePort port：8888是对应pod的端口号 nodePort：30088是service对外提供的调用端口号 另外，如果使用的是阿里云的镜像服务，在部署之前需要创建镜像拉取的秘钥，否则会拉取镜像失败，导致pod启动失败 kubectl create secret docker-registry aliyun-registry \\ --namespace=default \\ --docker-server=registry.cn-shanghai.aliyuncs.com \\ --docker-username=aliyun账户 \\ --docker-password=密码 \\ --docker-email=邮箱(非必选) 创建成功后，使用 kubectl get secrets 查看。 ","date":"2022-02-12","objectID":"/k8s%E9%83%A8%E7%BD%B2go%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/:4:0","tags":["k8s","集群部署"],"title":"k8s部署go应用入门实践","uri":"/k8s%E9%83%A8%E7%BD%B2go%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/"},{"categories":["kubernetes"],"content":"部署到k8s 配置文件准备就绪后，可以开始部署到k8s中，使用命令: kubectl create -f ./k8s/deployment.yaml kubectl create -f ./k8s/service.yaml 查看pod和service状况 kubectl get pod,svc -n default 可以看到如下 NAME READY STATUS RESTARTS AGE pod/hellogin-599968cc59-69qk6 1/1 Running 0 61m pod/hellogin-599968cc59-bmdkb 1/1 Running 0 61m pod/hellogin-599968cc59-tnqjz 1/1 Running 0 61m NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/hellogin-service NodePort 10.109.104.154 \u003cnone\u003e 8888:30088/TCP 60m service/kubernetes ClusterIP 10.96.0.1 \u003cnone\u003e 443/TCP 69m 三个pod(hellogin-xxxxxx-xxxx)处在Running状态，service的Port30088对外提供服务 ","date":"2022-02-12","objectID":"/k8s%E9%83%A8%E7%BD%B2go%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/:5:0","tags":["k8s","集群部署"],"title":"k8s部署go应用入门实践","uri":"/k8s%E9%83%A8%E7%BD%B2go%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/"},{"categories":["kubernetes"],"content":"访问确认 查看任何一个node的物理IP地址，通过访问node主机的IP:30088/test会返回当前时间，表示整个流程已经跑通 ","date":"2022-02-12","objectID":"/k8s%E9%83%A8%E7%BD%B2go%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/:6:0","tags":["k8s","集群部署"],"title":"k8s部署go应用入门实践","uri":"/k8s%E9%83%A8%E7%BD%B2go%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/"},{"categories":["编程"],"content":"GoLand内置的Diagrams功能不像IDEA一样强大，不支持生成类图。解决方案是利用github上的 PlantUML 类图生成器：jfeliu007/goplantuml ，结合Goland的PlantUML插件，对于golang源码项目的类图生成足够用了。 ","date":"2022-01-11","objectID":"/%E7%94%9F%E6%88%90go%E5%8C%85uml%E7%B1%BB%E5%9B%BE/:0:0","tags":["golang"],"title":"如何生成go包的uml类图","uri":"/%E7%94%9F%E6%88%90go%E5%8C%85uml%E7%B1%BB%E5%9B%BE/"},{"categories":["编程"],"content":"安装goplantuml go install github.com/jfeliu007/goplantuml/cmd/goplantuml@latest 将goplantuml可执行文件安装到本地$GOBIN目录下 ","date":"2022-01-11","objectID":"/%E7%94%9F%E6%88%90go%E5%8C%85uml%E7%B1%BB%E5%9B%BE/:0:1","tags":["golang"],"title":"如何生成go包的uml类图","uri":"/%E7%94%9F%E6%88%90go%E5%8C%85uml%E7%B1%BB%E5%9B%BE/"},{"categories":["编程"],"content":"集成goplantuml到goland 我们安装好可执行文件后，可以直接使用命令进行生成uml文件，诸如： goplantuml [-recursive] path/to/gofiles path/to/gofiles2 或 goplantuml [-recursive] path/to/gofiles path/to/gofiles2 \u003e diagram_file_name.puml 当然，这里会很麻烦，每次都需要打开命令行，然后定位到对应的路径下，敲一大串命令才能得到uml文件。这里，我们可以借助goland的External Tools，将命令集成到goland菜单中，我们需要使用的时候直接点击菜单按钮就生成了，非常快捷。 首先，打开settings/Tools/External Tools，点击＋号新增。 Name: goplanuml，或者随意取名； Program：C:\\Users\\wujunjie\\go\\bin\\goplantuml.exe，安装的goplantuml位置，请替换成你的GOBIN路径； Arguments: -recursive --output=$FileDir$.puml $FileDir$，这样应该够用了，当然你也可以使用 goplantuml -h 查看更多命令； working directory：.，当前路径就行。 保存后，选中一个go包，然后点击菜单按钮，输出了对应的uml文件表示成功。 ","date":"2022-01-11","objectID":"/%E7%94%9F%E6%88%90go%E5%8C%85uml%E7%B1%BB%E5%9B%BE/:0:2","tags":["golang"],"title":"如何生成go包的uml类图","uri":"/%E7%94%9F%E6%88%90go%E5%8C%85uml%E7%B1%BB%E5%9B%BE/"},{"categories":["编程"],"content":"安装PlantUML插件 生成uml文件了还是无法可视化查看，这里借助goland插件来生成类图，插件选择 PlantUML Integration ，直接在goland插件市场中安装即可。 ","date":"2022-01-11","objectID":"/%E7%94%9F%E6%88%90go%E5%8C%85uml%E7%B1%BB%E5%9B%BE/:0:3","tags":["golang"],"title":"如何生成go包的uml类图","uri":"/%E7%94%9F%E6%88%90go%E5%8C%85uml%E7%B1%BB%E5%9B%BE/"},{"categories":["编程"],"content":"其他 此外，作者还开发了一个在线版本的uml生成器 www.dumels.com，可以直接生成github仓库的源码uml图，非常的方便，可以先行体验，当然，给的源码包层次不能太深了，否则一些大型项目生成会失败。 ","date":"2022-01-11","objectID":"/%E7%94%9F%E6%88%90go%E5%8C%85uml%E7%B1%BB%E5%9B%BE/:0:4","tags":["golang"],"title":"如何生成go包的uml类图","uri":"/%E7%94%9F%E6%88%90go%E5%8C%85uml%E7%B1%BB%E5%9B%BE/"},{"categories":["Git"],"content":" 注：本文转载自 Git: submodule 子模块简明教程 | A Quest After Perspectives 如有侵权，联系删除 有种情况我们经常会遇到：某个工作中的项目需要包含并使用另一个项目。 也许是第三方库，或者你独立开发的，用于多个父项目的库。 现在问题来了：你想要把它们当做两个独立的项目，同时又想在一个项目中使用另一个。 Git 通过子模块来解决这个问题。 子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。 ","date":"2021-11-15","objectID":"/git%E5%AD%90%E6%A8%A1%E5%9D%97%E5%85%A5%E9%97%A8/:0:0","tags":["git"],"title":"【转载】git子模块入门","uri":"/git%E5%AD%90%E6%A8%A1%E5%9D%97%E5%85%A5%E9%97%A8/"},{"categories":["Git"],"content":"添加子模块 添加一个远程仓库项目 https://github.com/iphysresearch/GWToolkit.git 子模块到一个已有主仓库项目中。代码形式是 git submodule add \u003curl\u003e \u003crepo_name\u003e， 如下面的例子： $ git submodule add https://github.com/iphysresearch/GWToolkit.git GWToolkit 这时，你会看到一个名为 GWToolkit 的文件夹在你的主仓库目录中。 如果你是旧版 Git 的话，你会发现 ./GWToolkit 目录中是空的，你还需要在执行一步「更新子模块」，才可以把远程仓库项目中的内容下载下来。 $ git submodule update --init --recursive 如果你不小心把路径写错了，可以用下面的代码来删掉，详细可查阅 git help submodule。 $ git rm --cached GWToolkit 添加子模块后，若运行 git status，可以看到主仓库目录中会增加一个文件 .gitmodules，这个文件用来保存子模块的信息。 $ git status 位于分支 main 您的分支与上游分支 'origin/main' 一致。 要提交的变更： （使用 \"git restore --staged \u003c文件\u003e...\" 以取消暂存） 新文件： .gitmodules 新文件： GWToolkit 另外，在 .git/config 中会多出一块关于子模块信息的内容： [submodule \"GWToolkit\"] url = https://github.com/iphysresearch/GWToolkit.git active = true 该配置文件保存了项目 URL 与已经拉取的本地目录之间的映射。如果有多个子模块，该文件中就会有多条记录。 要重点注意的是，该文件也像 .gitignore 文件一样受到（通过）版本控制。 它会和该项目的其他部分一同被拉取推送。 这就是克隆该项目的人知道去哪获得子模块的原因。 新生成的还有相关子模块的文件：.git/modules/GWToolkit/。 此时若把上述「添加子模块」的修改更新到主仓库的 GitHub 上去的话，会看到相应子模块仓库的文件夹图标会有些不同： 此时还要留意的是，在终端 Git 命令操作下，位于主仓库目录中除了子模块外的任何子目录下进行的 commit 操作，都会记到主仓库下。只有在子模块目录内的任何 commit 操作，才会记到子模块仓库下。如下面的示例： $ cd ~/projects/\u003cmodule\u003e $ git log # log shows commits from Project \u003cmodule\u003e $ cd ~/projects/\u003cmodule\u003e/\u003csub_dir\u003e $ git log # still commits from Project \u003cmodule\u003e $ cd ~/projects/\u003cmodule\u003e/\u003csubmodule\u003e $ git log # commits from \u003csubmodule\u003e ","date":"2021-11-15","objectID":"/git%E5%AD%90%E6%A8%A1%E5%9D%97%E5%85%A5%E9%97%A8/:1:0","tags":["git"],"title":"【转载】git子模块入门","uri":"/git%E5%AD%90%E6%A8%A1%E5%9D%97%E5%85%A5%E9%97%A8/"},{"categories":["Git"],"content":"查看子模块 $ git submodule 13fe233bb134e25382693905cfb982fe58fa94c9 GWToolkit (heads/main) ","date":"2021-11-15","objectID":"/git%E5%AD%90%E6%A8%A1%E5%9D%97%E5%85%A5%E9%97%A8/:2:0","tags":["git"],"title":"【转载】git子模块入门","uri":"/git%E5%AD%90%E6%A8%A1%E5%9D%97%E5%85%A5%E9%97%A8/"},{"categories":["Git"],"content":"更新子模块 更新项目内子模块到最新版本： $ git submodule update 更新子模块为远程项目的最新版本 $ git submodule update --remote ","date":"2021-11-15","objectID":"/git%E5%AD%90%E6%A8%A1%E5%9D%97%E5%85%A5%E9%97%A8/:3:0","tags":["git"],"title":"【转载】git子模块入门","uri":"/git%E5%AD%90%E6%A8%A1%E5%9D%97%E5%85%A5%E9%97%A8/"},{"categories":["Git"],"content":"Clone 包含子模块的项目 对于你的主仓库项目合作者来说，如果只是 git clone 去下载主仓库的内容，那么你会发现子模块仓库的文件夹内是空的！ 此时，你可以像上面「添加子模块」中说到的使用 git submodule update --init --recursive 来递归的初始化并下载子模块仓库的内容。 也可以分初始化和更新子模块两步走的方式来下载子模块仓库的内容： $ git submodule init # 初始化子模块 $ git submodule update # 更新子模块 但是，如果你是第一次使用 git clone 下载主仓库的所有项目内容的话，我建议你可以使用如下的代码格式来把主仓库和其中子模块的所有内容，都一步到位的下载下来： $ git clone --recursive \u003cproject url\u003e 以后可以在子模块仓库目录下使用 git pull origin main 或者 git push 等来进行更新与合并等操作。 ","date":"2021-11-15","objectID":"/git%E5%AD%90%E6%A8%A1%E5%9D%97%E5%85%A5%E9%97%A8/:4:0","tags":["git"],"title":"【转载】git子模块入门","uri":"/git%E5%AD%90%E6%A8%A1%E5%9D%97%E5%85%A5%E9%97%A8/"},{"categories":["Git"],"content":"删除子模块 删除子模块比较麻烦，需要手动删除相关的文件，否则在添加子模块时有可能出现错误 同样以删除 GWToolkit 子模块仓库文件夹为例： 删除子模块文件夹 $ git rm --cached GWToolkit $ rm -rf GWToolkit 删除 .gitmodules 文件中相关子模块的信息，类似于： [submodule \"GWToolkit\"] path = GWToolkit url = https://github.com/iphysresearch/GWToolkit.git 删除 .git/config 中相关子模块信息，类似于： [submodule \"GWToolkit\"] url = https://github.com/iphysresearch/GWToolkit.git active = true 删除 .git 文件夹中的相关子模块文件 $ rm -rf .git/modules/GWToolkit ","date":"2021-11-15","objectID":"/git%E5%AD%90%E6%A8%A1%E5%9D%97%E5%85%A5%E9%97%A8/:5:0","tags":["git"],"title":"【转载】git子模块入门","uri":"/git%E5%AD%90%E6%A8%A1%E5%9D%97%E5%85%A5%E9%97%A8/"},{"categories":["Git"],"content":"最后的话 虽然 Git 提供的子模块功能已足够方便好用，但仍请在为主仓库项目添加子模块之前确保这是非常必要的。毕竟有很多编程语言（如 Go）或其他依赖管理工具（如 Ruby’s rubygems, Node.js’ npm, or Cocoa’s CocoaPods and Carthage）可以更好的 handle 类似的功能。 主仓库项目的合作者并不会自动地看到子模块仓库的更新通知的。所以，更新子模块后一定要记得提醒一下主仓库项目的合作者 git submodule update。 ","date":"2021-11-15","objectID":"/git%E5%AD%90%E6%A8%A1%E5%9D%97%E5%85%A5%E9%97%A8/:6:0","tags":["git"],"title":"【转载】git子模块入门","uri":"/git%E5%AD%90%E6%A8%A1%E5%9D%97%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"gcflags go build 可以用 -gcflags 给 go 编译器传入参数，也就是传给 go tool compile 的参数，因此可以用 go tool compile --help 查看所有可用的参数。 常⽤参数 -m 开启内存分配分析(逃逸)。可以帮助您找到可能存在的内存分配问题 -N 禁⽤优化 (debug时⽤到）可以⽤于⽣成调试信息 -l 禁⽌内联优化 (debug时⽤到） -L 错误信息中打印⽂件全名 gcflag传⼊的⽅式为： -gcflag=“pattern= args”,其中pattern代表取值分别为 main,all,std,…,⽤于指定编译参数作⽤的范围，args则为对应的编译参数 如果只在编译特定包时需要传递参数，格式应遵守“包名=参数列表”，如go build -gcflags -gcflags=‘log=-N -l’ main.go -gcflags “-N -l” 选项⽬的是在编译过程中禁⽌内联优化，加快编译速度减少开销 ","date":"2021-06-12","objectID":"/go%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/:1:0","tags":["golang","编译"],"title":"go程序编译优化","uri":"/go%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/"},{"categories":["编程"],"content":"Pattern main 指 main 函数所在的顶级包路径 all 表⽰ GOPATH 中的所有包。如果在 modules 模式下，则表⽰主模块和它所有的依赖，包括 test ⽂件的依赖 std 表⽰ Go 标准库中的所有包 ","date":"2021-06-12","objectID":"/go%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/:2:0","tags":["golang","编译"],"title":"go程序编译优化","uri":"/go%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/"},{"categories":["编程"],"content":"ldflags go build用 -ldflags 给go链接器传入参数，实际是给 go tool link 的参数，可以用 go tool link --help 查看可用的参数。 -w 去掉调试信息 -s 去掉符号表，panic时候的stack trace就没有任何⽂件名/⾏号信息了 -X 注⼊变量, 编译时赋值 -w 和 -s 通常⼀起使⽤，⽤来减少可执⾏⽂件的体积。但删除了调试信息后，可执⾏⽂件将⽆法使⽤ gdb/dlv 调试 -ldflags “-w -s” 选项⽬的是获取最⼩的⼆进制⽂件 -X 来指定版本号等编译时才决定的参数值，例如程序版本号 ","date":"2021-06-12","objectID":"/go%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/:3:0","tags":["golang","编译"],"title":"go程序编译优化","uri":"/go%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/"},{"categories":["编程"],"content":"项⽬使⽤ Develop 环境 -gcflags \"-l -N -m\" -ldflags \"\" Release 环境 -gcflags \"\" -ldflags \"-w -s\" ","date":"2021-06-12","objectID":"/go%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/:4:0","tags":["golang","编译"],"title":"go程序编译优化","uri":"/go%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/"},{"categories":["编程"],"content":"本文介绍 类型转换(Conversion)、类型断言(type assertion) 和类型切换（type switch)。 这三个概念类似但是又完全不同。 ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/:0:0","tags":["golang"],"title":"go的类型系统01","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/"},{"categories":["编程"],"content":"类型转换 Conversion 将一个值x转换成特定类型T,格式为 T(x),非常的简单，类型加小括号即可。 如果类型T以 *、\u003c-、func(不带结果列表)，未避免造成歧义，需要将类型括号包裹起来： (T)(x): *Point(p) // same as *(Point(p)) (*Point)(p) // p is converted to *Point \u003c-chan int(c) // same as \u003c-(chan int(c)) (\u003c-chan int)(c) // c is converted to \u003c-chan int func()(x) // function signature func() x (func())(x) // x is converted to func() (func() int)(x) // x is converted to func() int func() int(x) // x is converted to func() int (unambiguous) 并不是任意的值都可以转换成类型T, 它需要遵循一定的规则，下面一一道来。 对于一个常量值x, 如果能转换成T类型的值，它需要满足下面的条件之一: 转换常量值 x 可以表达为T的值 x 是浮点数值， T是浮点类型。 x 使用 IEEE 754 round-to-even 规则 且 IEEE -0.0 会进一步舍入到无符号的 0.0， 经过舍入后的x可以表示为T。这一条主要约束浮点数取整的规则，并不是完全按照四舍五入规则计算的。 x是一个整数而T是字符串类型 uint(iota) // iota value of type uint float32(2.718281828) // 2.718281828 of type float32 complex128(1) // 1.0 + 0.0i of type complex128 float32(0.49999999) // 0.5 of type float32 float64(-1e-1000) // 0.0 of type float64 string('x') // \"x\" of type string string(0x266c) // \"♬\" of type string MyString(\"foo\" + \"bar\") // \"foobar\" of type MyString string([]byte{'a'}) // not a constant: []byte{'a'} is not a constant (*int)(nil) // not a constant: nil is not a constant, *int is not a boolean, numeric, or string type int(1.2) // illegal: 1.2 cannot be represented as an int string(65.0) // illegal: 65.0 is not an integer constant 转换变量值 对于一个常量值x, 如果能转换成T类型的值，它需要满足下面的条件之一: x可以赋值给 T x的类型和T的底层类型 类型一致 x类型和T 都是未命名的指针类型，它们的指针指向的对象类型 类型一致 x的类型和T都是整数或者浮点数 x的类型和T都是复数 x是整数、slice of byte、slice of rune, T是字符串类型 x是字符串， T是slice of byte 或者slice of rune 数值类型和字符串之间的转换可能会改变x的呈现并且会带来运行时的花费。 其它的转换只是改变x的类型，不会改变x的呈现。 并没有直接整数和指针之间的转换。但是在前面的章节中也举例了，指针可以通过曲折的方式转换成整数， 它是通过包unsafe实现的， 甚至于你通过这种方式还可以访问struct未导出的字段。 类型不一致的两个变量不能赋值, 并且也没有什么强制类型转换的概念： var i1 int8 = 10 var i2 uint8 = i1 //错误 var i3 uint8 = (uint8)i1 //错误 比如在类型那一章讲的例子，也是通过这种类型转换实现的: x := [...]int{1, 2, 3, 4, 5} p := \u0026x[0] //p = p + 1 index2Pointer := unsafe.Pointer(uintptr(unsafe.Pointer(p)) + unsafe.Sizeof(x[0])) p = (*int)(index2Pointer) //x[1] fmt.Printf(\"%d\\n\", *p) //2 ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/:0:1","tags":["golang"],"title":"go的类型系统01","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/"},{"categories":["编程"],"content":"类型转换实践 这一节介绍常见类型一致的转换。 数值类型之间的转换 非常量的数值之间的转换遵循下面三条原则: 1、整数之间的转换时，如果值是有符号的整数，它的符号位会扩展无限大，否则零扩展，然后它会被删减以适合结果类型。怎么理解，看例子。 对于无符号数v: v := uint16(0x10F0),如果进行转换uint32(int8(v)),可以看到它的结果是0xFFFFFFF0，不会有溢出指示或者错误。 v1 := uint16(0x10F0) fmt.Printf(\"%d=%b\\n\", v1, v1) //4336=1000011110000 v2 := int8(v1) fmt.Printf(\"%d=%b\\n\", v2, v2) //-16=-10000 v3 := uint16(v2) fmt.Printf(\"%d=%b\\n\", v3, v3) //65520=1111111111110000 v4 := int16(v2) fmt.Printf(\"%d=%b\\n\", v4, v4) //-16=-10000 介绍一下。 对于v1,它是一个无符号的整数， 要把它转为有符号的int8，那么我们只看v1的后8位: 1111 0000 不幸的是，这个8位的最高位是1,我们会把它作为符号位，所以v2是个负数，那么11110000就是这个负数的补码， 那么它的原码是多少呢，计算补码的补码就是负数的原码:1001 0000,所以它是-16。如果最高位是0，简单了，本身就是它的原码。 再看v2转v3， 也就是有符号整数转无符号整数。v2是负数，内部表示为11110000,因为要扩展为16位，将符号位1扩展到最高位1111 1111 1111 0000,因为它是无符号整数，所以这个值整数的值65520。 你可以把v1值的值改为0xff60看看输出是什么？此时转换不会符号位为负数的情况。 补码（two’s complement) 指的是正数=原码，负数=反码加一 反码（ones’ complement) 指的就是通常所指的反码。 对一个整数的补码再求补码，等于该整数自身。 补码的正零与负零表示方法相同。 2、浮点数转换成整数时，小数部分被丢弃,也就是朝0方向舍入。 var v1 float32 = 0.999999 fmt.Println(int(v1)) v1 = -0.999999 fmt.Println(int(v1)) 3、当转换整数或者浮点数到浮点数的时候，或者一个复数到另一个复数， 结果值会被舍入到目标类型的精度。例如类型为float32的变量x可以通过附加的精度超过标准的IEEE-754 32-bit数， 但是float32(x)代表x的值舍入到 IEEE-754 32 bit的精度。类似地， x + 0.1 可以使用超过32 bit的精度，但是float32(x + 0.1) 肯定是32 bit的精度。 the value of a variable x of type float32 may be stored using additional precision beyond that of an IEEE-754 32-bit number, but float32(x) represents the result of rounding x’s value to 32-bit precision. Similarly, x + 0.1 may use more than 32 bits of precision, but float32(x + 0.1) does not. 关于浮点数格式IEEE-754, 随便一本计算机原理的教材中都会介绍，网上也有无数的文章介绍，它由三个域组成，float32中分别占1位、8位、和 23位,本文中就不详细介绍了。 整数和bool之间的转换 虽然有人提议实现快速的整数和bool之间的转换，但是目前看起来还没有实现，所以下面的语句是不对的： i1 := 1 i2 := 0 fmt.Printf(\"%t %t\\n\", bool(i1), bool(i2)) 但是你完全可以通过其它方式实现， 比如判断语句 n \u003e 0, 或者利用一个定义好的表(map,数组等)进行查表转换。 参考 https://github.com/golang/go/issues/6011 language: bool to numeric and numeric to bool type conversions · Issue #7657 · golang/go · GitHub 基于字节的字符串的转换 字符串代表一串字节流，所以很容易的和slice of byte, slice of rune进行转换。 1、无符号整数或者有符号整数通过它对应的UTF-8编码转换成字符串。合法的Unicode code之外的值都被转换成\\uFFFD。这里的整数也包含rune. string('a') // \"a\" string(-1) // \"\\ufffd\" == \"\\xef\\xbf\\xbd\" string(0xf8) // \"\\u00f8\" == \"ø\" == \"\\xc3\\xb8\" type MyString string MyString(0x65e5) // \"\\u65e5\" == \"日\" == \"\\xe6\\x97\\xa5\" 2、字节slice根据UTF-8编码产生字符串 string([]byte{'h', 'e', 'l', 'l', '\\xc3', '\\xb8'}) // \"hellø\" string([]byte{}) // \"\" string([]byte(nil)) // \"\" 3、将rune slice转换成字符串相当于将rune连接起来 string([]rune{0x9E1F, 0x7A9D}) // \"\\u9e1f\\u7a9d\" == \"鸟窝\" string([]rune{}) // \"\" string([]rune(nil)) // \"\" 4、将字符串转为byte slice会将字符串的字节流复制到一个byte slice 5、将一个字符串转为rune slice会将产生一个新的rune slice,包含字符串中每个rune 字符串和基本类型之间的转换 包strconv提供了字符串和基本数据类型的转换。上面我们提到了字符串和整数之间的转换，但是有时候我们需要的是将 12转换成字符串 “12”，或者从字符串中解析处一个整数，这个时候就可以使用这个包。 首先它提供了一组往byte slice增加基本类型元素的方法： func AppendBool(dst []byte, b bool) []byte func AppendFloat(dst []byte, f float64, fmt byte, prec, bitSize int) []byte func AppendInt(dst []byte, i int64, base int) []byte func AppendQuote(dst []byte, s string) []byte func AppendQuoteRune(dst []byte, r rune) []byte func AppendQuoteRuneToASCII(dst []byte, r rune) []byte func AppendQuoteRuneToGraphic(dst []byte, r rune) []byte func AppendQuoteToASCII(dst []byte, s string) []byte func AppendQuoteToGraphic(dst []byte, s string) []byte func AppendUint(dst []byte, i uint64, base int) []byte 一组从字符串中解析出基本类型的方法： func ParseBool(str string) (value bool, err error) func ParseFloat(s string, bitSize int) (f float64, err error) func ParseInt(s string, base int, bitSize int) (i int64, err error) func ParseUint(s string, base int, bitSize int) (n uint64, err error) 一组为字符串或者rune加引号和剥离引号的方法: func Quote(s string) string func QuoteRune(r rune) string func QuoteRuneToASCII(r rune) string func QuoteRuneToGraphic(r rune) string func QuoteToASCII(s string) string func QuoteToGraphic(s string) string func Unquote(s string) (t string, err error) func UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string, err error) 一组检查字符串或者rune为特定类型的方法： func CanBackquote(s string) ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/:0:2","tags":["golang"],"title":"go的类型系统01","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/"},{"categories":["编程"],"content":"类型断言 type assertion 和上节的类型转换不同，类型断言是将接口类型的值x，转换成类型T。 格式为： x.(T) v := x.(T) v, ok := x.(T) 类型断言的必要条件是x是接口类型,非接口类型的x不能做类型断言: var i int = 10 v := i.(int) //错误 T可以是非接口类型，如果想断言合法，则T应该实现x的接口。 T也可以是接口，则x的动态类型也应该实现接口T。 var x interface{} = 7 // x 的动态类型为int， 值为 7 i := x.(int) // i 的类型为 int， 值为 7 type I interface { m() } var y I s := y.(string) // 非法: string 没有实现接口 I (missing method m) r := y.(io.Reader) // y如果实现了接口io.Reader和I的情况下， r的类型则为io.Reader 类型断言如果非法，运行时时候就会出现 impossible type assertion panic，为了避免这种情况，可以使用下面的语法: v, ok = x.(T) v, ok := x.(T) var v, ok = x.(T) ok代表类型断言是否合法，如果非法ok =false,v为T的零值，这样就不会出现运行时panic了。 希望你能记住，类型转换和类型断言完全是两个概念。 ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/:0:3","tags":["golang"],"title":"go的类型系统01","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/"},{"categories":["编程"],"content":"类型切换 type switch 类型切换(暂且这么翻译吧，英语更准确)用来比较类型而不是对值进行比较。 switch语句虽然在下一章中去讲，但是对于读者来说，多少会一种或者几种常用的编程语言，switch是一个条件语句，它可以判断某个值是否匹配某个case clause。但是对于type switch，它检查的是值x的类型T是否匹配某个类型。 格式如下，类型类型断言，但是括号内的不是某个具体的类型，而是单词type: switch x.(type) { // cases } type switch语句中可以有一个简写的变量声明，这种情况下，等价于这个变量声明在每个case clause隐式代码块的开始位置。如果case clause只列出了一个类型，则变量的类型就是这个类型，否则就是原始值的类型。 假设下面的例子中x的类型为x interface{} switch i := x.(type) { case nil: printString(\"x is nil\") // i的类型是 x的类型 (interface{}) case int: printInt(i) // i的类型 int case float64: printFloat64(i) // i的类型是 float64 case func(int) float64: printFunction(i) // i的类型是 func(int) float64 case bool, string: printString(\"type is bool or string\") // i的类型是 x (interface{}) default: printString(\"don't know the type\") // i的类型是 x的类型 (interface{}) } 也许你已经看到上面的例子中有一个case clause中的类型是nil,它用来匹配x为nil的interface{}的情况。 ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/:0:4","tags":["golang"],"title":"go的类型系统01","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F01/"},{"categories":["编程"],"content":"本文介绍 类型别名与类型定义。 ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F02/:0:0","tags":["golang"],"title":"go的类型系统02","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F02/"},{"categories":["编程"],"content":"类型别名 类型别名需要在别名和原类型之间加上赋值符号 = ，使用类型别名定义的类型与原类型等价，Go 语言内建的基本类型中就存在两个别名类型。 byte 是 uint8 的别名类型； rune 是 int32 的别名类型； 类型别名定义形式如下： type MyString = string 上面代码表明 MyString 是 string 类型的别名类型。也就是说别名类型和源类型表示的是同一个目标，就譬如每个人的学名和乳名一样，都表示同一个人。 定义 string 类型的别名，示例代码： func main() { type MyString = string str := \"hello\" a := MyString(str) b := MyString(\"A\" + str) fmt.Printf(\"str type is %T\\n\", str) fmt.Printf(\"a type is %T\\n\", a) fmt.Printf(\"a == str is %t\\n\", a == str) fmt.Printf(\"b \u003e a is %t\\n\", b \u003e a) } 输出结果 str type is string a type is string a == str is true b \u003e a is false 定义 []string 类型的别名，示例代码： func main() { type MyString = string strs := []string{\"aa\", \"bb\", \"cc\"} a := []MyString(strs) fmt.Printf(\"strs type is %T\\n\", strs) fmt.Printf(\"a type is %T\\n\", a) fmt.Printf(\"a == nil is %t\\n\", a == nil) fmt.Printf(\"strs == nil is %t\\n\", strs != nil) } 运行结果为： strs type is []string a type is []string a == nil is false strs == nil is true 从上面结果可以得出以下结论： 别名类型与源类型是完全相同的； 别名类型与源类型可以在源类型支持的条件下进行相等判断、比较判断、与 nil 是否相等判断等； ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F02/:0:1","tags":["golang"],"title":"go的类型系统02","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F02/"},{"categories":["编程"],"content":"类型定义 类型定义是定义一种新的类型，它与源类型是不一样的。看下面代码： func main() { type MyString string str := \"hello\" a := MyString(str) b := MyString(\"A\" + str) fmt.Printf(\"str type is %T\\n\", str) fmt.Printf(\"a type is %T\\n\", a) fmt.Printf(\"a value is %#v\\n\", a) fmt.Printf(\"b value is %#v\\n\", b) // fmt.Printf(\"a == str is %t\\n\", a == str) fmt.Printf(\"b \u003e a is %t\\n\", b \u003e a) } 输出结果为： str type is string a type is main.MyString a value is \"hello\" b value is \"Ahello\" b \u003e a is false 可以看到 MyString 类型为 main.MyString 而原有的 str 类型为 string，两者是不同的类型，如果使用下面的判断相等语句 fmt.Printf(\"a == str is %t\\n\", a == str) 会有编译错误提示 invalid operation: a == str (mismatched types MyString and string) 说明类型不匹配。 下面代码 func main() { type MyString string strs := []string{\"E\", \"F\", \"G\"} myStrs := []MyString(strs) fmt.Println(myStrs) } 编译报错提示 cannot convert strs (type []string) to type []MyString 对于这里的类型再定义来说，string 可以被称为 MyString2 的潜在类型。潜在类型相同的不同类型的值之间是可以进行类型转换的。 因此，MyString2 类型的值与 string 类型的值可以使用类型转换表达式进行互转。但对于集合类的类型[]MyString2 与 []string 来说这样做却是不合法的，因为 []MyString2 与 []string 的潜在类型不同，分别是 []MyString2 和 []string 。 另外，即使两个不同类型的潜在类型相同，它们的值之间也不能进行判等或比较，它们的变量之间也不能赋值。 func main() { type MyString1 = string type MyString2 string str := \"BCD\" myStr1 := MyString1(str) myStr2 := MyString2(str) myStr1 = MyString1(myStr2) myStr2 = MyString2(myStr1) myStr1 = str myStr2 = str // cannot use str (type string) as type MyString2 in assignment myStr1 = myStr2 // cannot use myStr2 (type MyString2) as type string in assignment myStr2 = myStr1 // cannot use myStr1 (type string) as type MyString2 in assignment } ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F02/:0:2","tags":["golang"],"title":"go的类型系统02","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F02/"},{"categories":["编程"],"content":"类型别名注意点 类型循环 类型别名在定义的时候不允许出现循环定义别名的情况，如下面所示： type T1 = T2 type T2 = T1 上面的例子太明显，下面这个例子比较隐蔽，也是循环定义类型别名的情况，当然这些在编译代码的时候编译器会帮你检查，如果出现循环定义的情况会出错。 type T1 = struct { next *T2 } type T2 = T1 可导出性 如果定义的类型别名是exported (首字母大写)的，那么别的包中就可以使用，它和原始类型是否可exported没关系。也就是说，你可以为unexported类型定义一个exported的类型别名，如下面的例子： type t1 struct { S string } type T2 = t1 方法集 既然类型别名和原始类型是相同的，那么它们的方法集也是相同的。 下面的例子中T1和T3都有say和greeting方法。 type T1 struct{} type T3 = T1 func (t1 T1) say(){} func (t3 *T3) greeting(){} func main() { var t1 T1 // var t2 T2 var t3 T3 t1.say() t1.greeting() t3.say() t3.greeting() } 如果类型别名和原始类型定义了相同的方法，代码编译的时候会报错，因为有重复的方法定义。 另一个有趣的现象是 embedded type, 比如下面的例子， T3是T1的别名。在定义结构体S的时候，我们使用了匿名嵌入类型，那么这个时候调用s.say会怎么样呢？ 实际是你会编译出错，因为s.say｀不知道该调用s.T1.say还是s.T3.say`，所以这个时候你需要明确的调用。 type T1 struct{} type T3 = T1 func (t T1) say(){} type S struct { T1 T3 } func main() { var s S s.say() } 进一步想，这样是不是我们可以为其它库中的类型增加新的方法了， 比如为标准库的time.Time增加一个滴答方法: type NTime = time.Time func (t NTime) Dida() { fmt.Println(\"嘀嗒嘀嗒\") } func main() { t := time.Now() t.Dida() } 答案是: NO, 编译的时候会报错: cannot define new methods on non-local type time.Time。 ","date":"2021-04-13","objectID":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F02/:0:3","tags":["golang"],"title":"go的类型系统02","uri":"/go%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F02/"},{"categories":["编程"],"content":"最近在读Go源码时发现高频注释语句“XXX must not be copied after first use“。例如sync包下的Pool、Cond、WaitGroup、Mutex、Map和atomoic.Vaule、strings.Builder等，都有该句注释。 ","date":"2021-02-11","objectID":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/:0:0","tags":["golang"],"title":"go的noCopy机制","uri":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/"},{"categories":["编程"],"content":"为什么注释文档中要强调no copy？ 安全！ 如果结构体对象包含指针字段，当该对象被拷贝时，会使得两个对象中的指针字段变得不再安全。 type S struct { f1 int f2 *s } type s struct { name string } func main() { mOld := S{ f1: 0, f2: \u0026s{name: \"mike\"}, } mNew := mOld //拷贝 mNew.f1 = 1 mNew.f2.name = \"jane\" fmt.Println(mOld.f1, mOld.f2) //输出：0 \u0026{jane} } 如上，结构体对象S中存在两个field，分别是f1和f2，其中f2是指向s类型的指针。当mNew复制了mOld之后，mNew对两个字段进行了改变，可以看到f1字段的更改，不会对mOld造成影响。但是，nNew中f2字段的修改也会把mOld中的f2字段修改掉，这引发了安全问题。 ","date":"2021-02-11","objectID":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/:1:0","tags":["golang"],"title":"go的noCopy机制","uri":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/"},{"categories":["编程"],"content":"Go是如何保证no copy的？ ","date":"2021-02-11","objectID":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/:2:0","tags":["golang"],"title":"go的noCopy机制","uri":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/"},{"categories":["编程"],"content":"runtime checking strings.Builder中copy检查 func main() { var a strings.Builder a.Write([]byte(\"a\")) b := a b.Write([]byte(\"b\")) } // 运行报错：strings: illegal use of non-zero Builder copied by value 报错信息，来源于strings.Builder的copyCheck。 type Builder struct { addr *Builder // of receiver, to detect copies by value buf []byte } func (b *Builder) Write(p []byte) (int, error) { b.copyCheck() b.buf = append(b.buf, p...) return len(p), nil } func (b *Builder) copyCheck() { if b.addr == nil { b.addr = (*Builder)(noescape(unsafe.Pointer(b))) } else if b.addr != b { panic(\"strings: illegal use of non-zero Builder copied by value\") } } 在Builder中，addr是一个指向自身的指针。当对上文中的a复制给b时，a和b本身是不同的对象。因此，b.addr实际还是指向a的指针，这就会触发条件b.addr!=b，造成panic。 sync.Cond中copy检查 在源码中，拥有copy检查机制的还有sync.Cond。 type Cond struct { noCopy noCopy L Locker notify notifyList checker copyChecker } func (c *Cond) Wait() { c.checker.check() ... } type copyChecker uintptr func (c *copyChecker) check() { if uintptr(*c) != uintptr(unsafe.Pointer(c)) \u0026\u0026 !atomic.CompareAndSwapUintptr((*uintptr)(c), 0, uintptr(unsafe.Pointer(c))) \u0026\u0026 uintptr(*c) != uintptr(unsafe.Pointer(c)) { panic(\"sync.Cond is copied\") } } 这里的check函数初看不易明白。因此，定义一个相似的结构体对象，来探究这里的check函数究竟是如何做copy检查的。 type cond struct { checker copyChecker } type copyChecker uintptr func (c *copyChecker) check() { fmt.Printf(\"Before: c: %12v, *c: %12v, uintptr(*c): %12v, uintptr(unsafe.Pointer(c)): %12v\\n\", c, *c, uintptr(*c), uintptr(unsafe.Pointer(c))) swapped := atomic.CompareAndSwapUintptr((*uintptr)(c), 0, uintptr(unsafe.Pointer(c))) fmt.Printf(\"After : c: %12v, *c: %12v, uintptr(*c): %12v, uintptr(unsafe.Pointer(c)): %12v, swapped: %12v\\n\", c, *c, uintptr(*c), uintptr(unsafe.Pointer(c)), swapped) } func main() { var a cond a.checker.check() b := a b.checker.check() } // 输出 Before: c: 0xc0000b4008, *c: 0, uintptr(*c): 0, uintptr(unsafe.Pointer(c)): 824634458120 After : c: 0xc0000b4008, *c: 824634458120, uintptr(*c): 824634458120, uintptr(unsafe.Pointer(c)): 824634458120, swapped: true Before: c: 0xc0000b4040, *c: 824634458120, uintptr(*c): 824634458120, uintptr(unsafe.Pointer(c)): 824634458176 After : c: 0xc0000b4040, *c: 824634458120, uintptr(*c): 824634458120, uintptr(unsafe.Pointer(c)): 824634458176, swapped: false 这下，sync.Cond的copy检查就很清晰了。当a被b copy之后，uintptr(*c)和uintptr(unsafe.Pointer(c))的值是不同的，通过uint对象的原子比较方法CompareAndSwapUintptr将返回false，它证明了对象a被copy过，从而调用panic保护sync.Cond不被复制。 ","date":"2021-02-11","objectID":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/:2:1","tags":["golang"],"title":"go的noCopy机制","uri":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/"},{"categories":["编程"],"content":"go vet checking 上述两个例子都是在程序编译后，runtime检查的。但是，正如文中开篇所述，sync包下的其他的对象如Pool、WaitGroup、Mutex、Map等，它们其实也需要copy检查机制，但是在源码中，却没有提供运行时检查。那该如何保证我们的代码中这些对象在使用中未被copy，从而避免潜在的安全问题呢？ Go在源代码src/sync/cond.go中的一段注释给了我们答案。 // noCopy may be embedded into structs which must not be copied // after the first use. // // See https://golang.org/issues/8005#issuecomment-190753527 // for details. type noCopy struct{} // Lock is a no-op used by -copylocks checker from `go vet`. func (*noCopy) Lock() {} func (*noCopy) Unlock() {} 很明显，runtime时的copy检查虽然很重要，但是，该操作会影响程序的执行性能。Go官方目前只提供了strings.Builder和sync.Cond的runtime拷贝检查机制，对于其他需要nocopy对象类型来说，使用go vet工具来做静态编译检查。 具体实施来说，就是该对象，或对象中存在filed，它拥有Lock()和Unlock()方法，即实现sync.Locker接口。之后，可以通过go vet功能，来检查代码中该对象是否有被copy。 例如sync.Pool和sync.WaitGroup就内嵌了noCopy属性，sync.Mutex实现了sync.Locker接口，sync.Map内嵌了sync.Mutex。 静态检查 // wg.go package main import \"sync\" func main() { var sm sync.Mutex sm.Lock() sm.Unlock() sm2 := sm sm2.Lock() } 如上，sm在first use后，被copy给sm2。注意：该代码运行时，不会报错，但是却存在安全隐患。 $ go vet wg.go # command-line-arguments ./wg.go:9:9: assignment copies lock value to sm2: sync.Mutex 通过以上命令，即可检查出sync.Mutex有被copy。因此，举一反三，如果在我们自己的项目开发中，定义某对象不能被copy，那么就可以参考Go源码中，嵌入noCopy结构体，最终通过go vet进行copy检查。 type noCopy struct{} func (*noCopy) Lock() {} func (*noCopy) Unlock() {} type MyType struct { noCopy noCopy ... } ","date":"2021-02-11","objectID":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/:2:2","tags":["golang"],"title":"go的noCopy机制","uri":"/go%E7%9A%84nocopy%E6%9C%BA%E5%88%B6/"},{"categories":["编程"],"content":"chan操作规则 在介绍select-case实现机制之前，最好先了解下chan操作规则，明白goroutine何时阻塞，又在什么时机被唤醒，这对后续理解select-case实现有帮助。所以接下来先介绍chan操作规则，然后再介绍select-case的实现。 ","date":"2020-07-10","objectID":"/go%E7%9A%84select-case%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/:1:0","tags":["golang"],"title":"go的select-case实现机制","uri":"/go%E7%9A%84select-case%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"},{"categories":["编程"],"content":"规则1 当一个goroutine要从一个non-nil \u0026 non-closed chan上接收数据时，goroutine首先会去获取chan上的锁，然后执行如下操作直到某个条件被满足： 1）如果chan上的value buffer不空，这也意味着chan上的recv goroutine queue也一定是空的，该接收goroutine将从value buffer中unshift出一个value。这个时候，如果send goroutine队列不空的情况下，因为刚才value buffer中空出了一个位置，有位置可写，所以这个时候会从send goroutine queue中unshift出一个发送goroutine并让其恢复执行，让其执行把数据写入chan的操作，实际上是恢复该发送该goroutine执行，并把该发送goroutine要发送的数据push到value buffer中。然后呢，该接收goroutine也拿到了数据了，就继续执行。这种情景，channel的接收操作称为non-blocking操作。 2）另一种情况，如果value buffer是空的，但是send goroutine queue不空，这种情况下，该chan一定是unbufferred chan，不然value buffer肯定有数据嘛，这个时候接收goroutine将从send goroutine queue中unshift出一个发送goroutine，并将该发送goroutine要发送的数据接收过来（两个goroutine一个有发送数据地址，一个有接收数据地址，拷贝过来就ok），然后这个取出的发送goroutine将恢复执行，这个接收goroutine也可以继续执行。这种情况下，chan接收操作也是non-blocking操作。 3）另一种情况，如果value buffer和send goroutine queue都是空的，没有数据可接收，将把该接收goroutine push到chan的recv goroutine queue，该接收goroutine将转入blocking状态，什么时候恢复期执行呢，要等到有一个goroutine尝试向chan发送数据的时候了。这种场景下，chan接收操作是blocking操作。 ","date":"2020-07-10","objectID":"/go%E7%9A%84select-case%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/:1:1","tags":["golang"],"title":"go的select-case实现机制","uri":"/go%E7%9A%84select-case%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"},{"categories":["编程"],"content":"规则2 当一个goroutine尝试向一个non-nil \u0026 non-closed chan发送数据的时候，该goroutine将先尝试获取chan上的锁，然后执行如下操作直到满足其中一种情况。 1）如果chan的recv goroutine queue不空，这种情况下，value buffer一定是空的。发送goroutine将从recv goroutine queue中unshift出一个recv goroutine，然后直接将自己要发送的数据拷贝到该recv goroutine的接收地址处，然后恢复该recv goroutine的运行，当前发送goroutine也继续执行。这种情况下，chan send操作是non-blocking操作。 2）如果chan的recv goroutine queue是空的，并且value buffer不满，这种情况下，send goroutine queue一定是空的，因为value buffer不满发送goroutine可以发送完成不可能会阻塞。该发送goroutine将要发送的数据push到value buffer中然后继续执行。这种情况下，chan send操作是non-blocking操作。 3）如果chan的recv goroutine queue是空的，并且value buffer是满的，发送goroutine将被push到send goroutine queue中进入阻塞状态。等到有其他goroutine尝试从chan接收数据的时候才能将其唤醒恢复执行。这种情况下，chan send操作是blocking操作。 ","date":"2020-07-10","objectID":"/go%E7%9A%84select-case%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/:1:2","tags":["golang"],"title":"go的select-case实现机制","uri":"/go%E7%9A%84select-case%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"},{"categories":["编程"],"content":"规则3 当一个goroutine尝试close一个non-nil \u0026 non-closed chan的时候，close操作将依次执行如下操作。 1）如果chan的recv goroutine queue不空，这种情况下value buffer一定是空的，因为如果value buffer如果不空，一定会继续unshift recv goroutine queue中的goroutine接收数据，直到value buffer为空（这里可以看下chan send操作，chan send写入数据之前，一定会从recv goroutine queue中unshift出一个recv goroutine）。recv goroutine queue里面所有的goroutine将一个个unshift出来并返回一个val=0值和sentBeforeClosed=false。 2）如果chan的send goroutine queue不空，所有的goroutine将被依次取出并生成一个panic for closing a close chan。在这close之前发送到chan的数据仍然在chan的value buffer中存着。 ","date":"2020-07-10","objectID":"/go%E7%9A%84select-case%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/:1:3","tags":["golang"],"title":"go的select-case实现机制","uri":"/go%E7%9A%84select-case%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"},{"categories":["编程"],"content":"规则4 一旦chan被关闭了，chan recv操作就永远也不会阻塞，chan的value buffer中在close之前写入的数据仍然存在。一旦value buffer中close之前写入的数据都被取出之后，后续的接收操作将会返回val=0和sentBeforeClosed=true。 ","date":"2020-07-10","objectID":"/go%E7%9A%84select-case%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/:1:4","tags":["golang"],"title":"go的select-case实现机制","uri":"/go%E7%9A%84select-case%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"},{"categories":["编程"],"content":"小结 理解这里的goroutine的blocking、non-blocking操作对于理解针对chan的select-case操作是很有帮助的。下面介绍select-case实现机制。 ","date":"2020-07-10","objectID":"/go%E7%9A%84select-case%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/:1:5","tags":["golang"],"title":"go的select-case实现机制","uri":"/go%E7%9A%84select-case%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"},{"categories":["编程"],"content":"select-case实现 ","date":"2020-07-10","objectID":"/go%E7%9A%84select-case%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/:2:0","tags":["golang"],"title":"go的select-case实现机制","uri":"/go%E7%9A%84select-case%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"},{"categories":["编程"],"content":"原理简述 select-case中假如没有default分支的话，一定要等到某个case分支满足条件然后将对应的goroutine唤醒恢复执行才可以继续执行，否则代码就会阻塞在这里，即将当前goroutine push到各个case分支对应的ch的recv或者send goroutine queue中，对同一个chan也可能将当前goroutine同时push到recv、send goroutine queue这两个队列中。 不管是普通的chan send、recv操作，还是select chan send、recv操作，因为chan操作阻塞的goroutine都是依靠其他goroutine对chan的send、recv操作来唤醒的。前面我们已经讲过了goroutine被唤醒的时机，这里还要再细分一下。 chan的send、recv goroutine queue中存储的其实是一个结构体指针*sudog，成员gp *g指向对应的goroutine，elem unsafe.Pointer指向待读写的变量地址，c *hchan指向goroutine阻塞在哪个chan上，isSelect为true表示select chan send、recv，反之表示chan send、recv。g.selectDone表示select操作是否处理完成，即是否有某个case分支已经成立。 ","date":"2020-07-10","objectID":"/go%E7%9A%84select-case%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/:2:1","tags":["golang"],"title":"go的select-case实现机制","uri":"/go%E7%9A%84select-case%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"},{"categories":["编程"],"content":"执行流程 chan操作阻塞的goroutine唤醒时执行逻辑 下面我们先描述下chan上某个goroutine被唤醒时的处理逻辑，假如现在有个goroutine因为select chan 操作阻塞在了ch1、ch2上，那么会创建对应的sudog对象，并将对应的指针*sudog push到各个case分支对应的ch1、ch2上的send、recv goroutine queue中，等待其他协程执行(select) chan send、recv操作时将其唤醒： 1）源码文件chan.go，假如现在有另外一个goroutine对ch1进行了操作，然后对ch1的goroutine执行unshift操作取出一个阻塞的goroutine，在unshift时要执行方法 func (q *waitq) dequeue() *sudog ，这个方法从ch1的等待队列中返回一个阻塞的goroutine。 func (q *waitq) dequeue() *sudog { for { sgp := q.first if sgp == nil { return nil } y := sgp.next if y == nil { q.first = nil q.last = nil } else { y.prev = nil q.first = y sgp.next = nil // mark as removed (see dequeueSudog) } // if a goroutine was put on this queue because of a // select, there is a small window between the goroutine // being woken up by a different case and it grabbing the // channel locks. Once it has the lock // it removes itself from the queue, so we won't see it after that. // We use a flag in the G struct to tell us when someone // else has won the race to signal this goroutine but the goroutine // hasn't removed itself from the queue yet. if sgp.isSelect { if !atomic.Cas(\u0026sgp.g.selectDone, 0, 1) { continue } } return sgp } } 假如队首元素就是之前阻塞的goroutine，那么检测到其sgp.isSelect=true，就知道这是一个因为select chan send、recv阻塞的goroutine，然后通过CAS操作将sgp.g.selectDone设为true标识当前goroutine的select操作已经处理完成，之后就可以将该goroutine返回用于从value buffer读或者向value buffer写数据了，或者直接与唤醒它的goroutine交换数据，然后该阻塞的goroutine就可以恢复执行了。 这里将sgp.g.selectDone设为true，相当于传达了该sgp.g已经从刚才阻塞它的select-case块中退出了，对应的select-case块可以作废了。有必要提提一下为什么要把这里的sgp.g.selectDone设为true呢？直接将该goroutine出队不就完了吗？不行！考虑以下对chan的操作dequeue是需要先拿到chan上的lock的，但是在尝试lock chan之前有可能同时有多个case分支对应的chan准备就绪。看个示例代码： // g1 go func() { ch1 \u003c- 1\u2028}() // g2 go func() { ch2 \u003c- 2 } select { case \u003c- ch1: doSomething() case \u003c- ch2: doSomething() } 协程g1在 chan.chansend方法中执行了一半，准备lock ch1，协程g2也执行了一半，也准备lock ch2; 协程g1成功lock ch1执行dequeue操作，协程g2也成功lock ch2执行dequeue操作； 因为同一个select-case块中只能有一个case分支允许激活，所以在协程g里面加了个成员g.selectDone来标识该协程对应的select-case是否已经成功执行结束（一个协程在某个时刻只可能有一个select-case块在处理，要么阻塞没执行完，要么立即执行完），因此dequeue时要通过CAS操作来更新g.selectDone的值，更新成功者完成出队操作激活case分支，CAS失败的则认为该select-case已经有其他分支被激活，当前case分支作废，select-case结束。 这里的CAS操作也就是说的多个分支满足条件时，golang会随机选择一个分支执行的道理。 select-case块golang是如何执行处理的 源文件select.go中方法 selectgo(sel *hselect) ，实现了对select-case块的处理逻辑，但是由于代码篇幅较长，这里不再复制粘贴代码，感兴趣的可以自己查看，这里只简要描述下其执行流程。 selectgo逻辑处理简述： 预处理部分 对各个case分支按照ch地址排序，保证后续按序加锁，避免产生死锁问题； pass 1 部分处理各个case分支的判断逻辑，依次检查各个case分支是否有立即可满足ch读写操作的。如果当前分支有则立即执行ch读写并回，select处理结束；没有则继续处理下一分支；如果所有分支均不满足继续执行以下流程。 pass 2 没有一个case分支上chan操作立即可就绪，当前goroutine需要阻塞，遍历所有的case分支，分别构建goroutine对应的sudog并push到case分支对应chan的对应goroutine queue中。然后gopark挂起当前goroutine，等待某个分支上chan操作完成来唤醒当前goroutine。怎么被唤醒呢？前面提到了chan.waitq.dequeue()方法中通过CAS将sudog.g.selectDone设为1之后将该sudog返回并恢复执行，其实也就是借助这个操作来唤醒。 pass 3 整个select-case块已经结束使命，之前阻塞的goroutine已被唤醒，其他case分支没什么作用了，需要废弃掉，pass 3部分会将该goroutine从之前阻塞它的select-case块中各case分支对应的chan recv、send goroutine queue中移除，通过方法chan.waitq.dequeueSudog(sgp *sudog)来从队列中移除，队列是双向链表，通过sudog.prev和sudog.next删除sudog时间复杂度为O(1)。 ","date":"2020-07-10","objectID":"/go%E7%9A%84select-case%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/:2:2","tags":["golang"],"title":"go的select-case实现机制","uri":"/go%E7%9A%84select-case%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"},{"categories":["其他"],"content":"建立博客以来，试用了多款评论系统，不过最终还是用了 disqus，但是 disqus 令人讨厌的是默认添加很多烦人的广告，牛皮癣一样，而且在国内无法加载，必须翻墙才能显示。utterances 是一款基于 github issues 的评论系统，简洁，避免了 disqus 的广告以及加载问题。这篇文章总结如何给 LoveIt 主题添加 utterances 评论系统。 注：该主题已经支持了utterances，所以我们只需要简单配置就能使用，如果你使用的主题还不支持，需要按照文档进行代码嵌入 操作如下： 建立一个 public GitHub 仓库，这个仓库的 issue 用来存放博客评论：如果自己的博客就是用 GitHub pages 建立的，那么就不需要额外建立仓库了，就用博客的仓库也可以。例如我的博客放在 bychannel/bychannel.github.io这个仓库，就可以用这个仓库存放博客的评论。 安装 utterances 的 app：install 以后，在 Repository access，选择 Only select repositories，然后选择自己建立的用来存放评论的仓库即可。这时，进入到对应仓库的设置界面，点击 Integrations，会看到 utterances 的 app。 Hugo 对应的设置：主题已经支持了 utterances，在博客的 config.toml 配置文件，加入下面的配置： [params.page.comment.utterances] enable = true # owner/repo repo = \"bychannel/bychannel.github.io\" issueTerm = \"pathname\" label = \"comment\" lightTheme = \"github-light\" darkTheme = \"github-dark\" 重新 deploy Hugo 博客，等博客更新以后，utterances 评论系统即可生效。 要在博客文章下面评论，只需要登录自己的 GitHub 账号即可。 ","date":"2020-06-09","objectID":"/%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0utterances%E8%AF%84%E8%AE%BA/:0:0","tags":["blog"],"title":"博客添加utterances评论","uri":"/%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0utterances%E8%AF%84%E8%AE%BA/"},{"categories":["其他"],"content":"这里记录一下hugo静态博客的搭建过程，本文假设你已经了解hugo、github、github pages的相关知识，不清楚可以先去google了解一下。 我的方案主要分为以下几个核心部分： 个人博客源仓库，对博客配置及所有文章 .md 源文件进行版本管理，配合 GitHub Action 进行自动化部署，自动生成静态站点推送到 GitHub Pages 博客发布仓库。 GitHub Pages 博客发布仓库，以 username.github.io 形式命名的仓库，使用 GitHub Pages 实现网站部署，可以通过配置域名 CNAME 解析使用自定义域名。 Hugo 主题仓库，fork 喜欢的主题，并对自己的个人定制化改造配置进行版本管理，通过 git submodule 的方式链接到个人博客源仓库。 下文会对搭建、本地测试、自动化部署维护等过程进行详细讲解，希望对大家所有帮助。其他组件配置，如网站统计、评论系统等我们后面在慢慢补充。 ","date":"2020-06-07","objectID":"/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:0:0","tags":["blog"],"title":"自动化博客搭建记录","uri":"/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["其他"],"content":"博客源仓库 其实这个就是hugo的源工程，我们最终会把这个源工程提交到git仓库中进行版本管理，这样，我们的文章也就有版本了，见本站的源工程 前提 在此之前，你现在的环境中需要一下工具： hugo，最好是带extend的扩展版本，在编译主题中带有scss文件会用上，点此处 git，部署到github用到的工具，没有安装的话，直接下最新版本就好了 hugo工程 使用命令 hugo new site blog 就可以创建初始化一个hugo项目 主题 我们先点这里选择一个喜欢的主题，我的做法是fork了主题的github源码，自己如果有想法可以进行自定义修改，然后是把主题添加到hugo工程的themes目录下，这里建议使用子模块的方式进行添加： git submodule add https://github.com/bychannel/LoveIt themes/LoveIt 进入themes/LoveIt/exampleSite，这是主题的使用案例，可以直接复制config.toml文件覆盖hugo工程的配置，然后修改其中的参数，并参照exampleSite下的资源路径配置，文章路径，直接照搬使用即可，这样操作下来博客的雏形就好了。 新建文章 现在可以尝试写一篇测试文章看看，直接使用命令hugo new posts/test.md就能生成一篇新文章，文件路径在content/posts下，或者我们可以直接进入该路径下，复制一个markdown文章进行改写。 文章保存后，使用命令编译一下查看效果： hugo server -D 打开localhost:1313就能进行预览，如果效果不好，我们还可以修改markdown或者toml配置文件，并能够在浏览器实时查看修改后的效果。 ","date":"2020-06-07","objectID":"/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:0:1","tags":["blog"],"title":"自动化博客搭建记录","uri":"/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["其他"],"content":"pages仓库 每次使用hugo server命令进行编译，会在public目录下生成网站的静态资源，这些html、css等资源就是我们在浏览器中看到的页面了，我们需要单独把他发布出去。 创建仓库 GitHub Pages 项目需要符合 username.github.io 的特殊命名格式，仓库建立完成后，可以在设置中配置自己注册的自定义域名来指向 GitHub Pages 生成的网址。此外，需要将博客站点配置文件 config.toml 中的 baseURL 改为自己的自定义域名，这样博客站点才能正常访问 GitHub Pages 生成的网站服务。 域名配置 如果你购买了域名，不使用默认的username.github.io，那你需要在购买域名的后台系统进行域名重定向配置，这里我没有购买域名，就不再进行演示了，自己实操一下应该是没问题的。 自动发布 能自动化处理的事情，我们绝不手动处理，不仅仅是重复的劳动，更是因为手动更加容易出错。 因为我们的博客基于 GitHub 与 GitHub Pages，可以通过官方提供的 GitHub Action 进行 CI 自动发布，下面我会进行详细讲解。GitHub Action 是一个持续集成和持续交付(CI/CD) 平台，可用于自动执行构建、测试和部署管道，目前已经有很多开发好的工作流，可以通过简单的配置即可直接使用。 配置在仓库目录 .github/workflows 下，以 .yml 为后缀。我的 GitHub Action 配置，自动发布示例配置如下 name: deploy on: push: workflow_dispatch: schedule: # Runs everyday at 8:00 AM - cron: \"0 0 * * *\" jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \"latest\" extended: true - name: Build Web run: hugo - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: bychannel/bychannel.github.io PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} on 表示 GitHub Action 触发条件，我设置了 push、workflow_dispatch 和 schedule 三个条件： push，当这个项目仓库发生推送动作后，执行 GitHub Action workflow_dispatch，可以在 GitHub 项目仓库的 Action 工具栏进行手动调用 schedule，定时执行 GitHub Action，如我的设置为北京时间每天早上执行，主要是使用一些自动化统计 CI 来自动更新我博客的关于页面 jobs 表示 GitHub Action 中的任务，我们设置了一个 build 任务，runs-on 表示 GitHub Action 运行环境，我们选择了 ubuntu-latest。我们的 build 任务包含了 Checkout、Setup Hugo、Build Web 和 Deploy Web 四个主要步骤，其中 run 是执行的命令，uses 是 GitHub Action 中的一个插件，我们使用了 peaceiris/actions-hugo@v2 和 peaceiris/actions-gh-pages@v3 这两个插件。其中 Checkout 步骤中 with 中配置 submodules 值为 true 可以同步博客源仓库的子模块，即我们的主题模块。 大家可以根据自己的实际情况进行配置改写，然后加入到工程的对应路径下，github会按照配置自动执行。 token配置 因为我们需要从一个git仓库push到另一个git仓库，那么需要进行对应的token配置，以便推送的时候能正确的进行权限认证。 首先要在 GitHub 账户下 Setting - Developer setting - Personal access tokens - Tokens(classic) 下创建一个 Token。权限需要开启 repo 与 workflow，选择永不过期。 配置后复制生成的 Token（注：只会出现一次），然后在我们博客源仓库的 Settings - Secrets and variables - Actions 中，添加密钥 PERSONAL_TOKEN 为刚才的 Token，这样 GitHub Action 就可以获取到 Token 了。 完成上述配置后，推送代码至仓库，即可触发 GitHub Action，自动生成博客页面并推送至 GitHub Pages 仓库。 ","date":"2020-06-07","objectID":"/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:0:2","tags":["blog"],"title":"自动化博客搭建记录","uri":"/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["其他"],"content":"总结 以上就是我通过 Hugo 与 GitHub Action 实现的博客自动部署系统，我自己的实现仓库如下： 博客源码仓库 https://github.com/bychannel/blog， 主题仓库 https://github.com/bychannel/LoveIt ， 发布仓库 https://github.com/bychannel/bychannel.github.io 这样整理下来，我们不仅可以随时修改整个博客，而且流程全自动化，我们只需要专注于产出文章，然后提交到源仓库就可以了。 如果还有不清楚或者没讲明白的地方，大家可以下面评论区提出来讨论一下。 ","date":"2020-06-07","objectID":"/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:0:3","tags":["blog"],"title":"自动化博客搭建记录","uri":"/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"我是谁 我是池鱼，是当年加入小牛时所取的花名，选自陶渊明的《归园田居·其一》中的”羁鸟恋旧林，池鱼思故渊“，之所以选择”池鱼“作为花名，也是和作者有类型心境，不堪束缚，渴望自由。 一名手游后端开发者，目前已经在游戏行业混迹了快5年，在创业公司干过多面手，也在大公司当过螺丝钉，各种主流语言都会一点，目前专注golang以及相关生态项目。 ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"关于作者","uri":"/about/"},{"categories":null,"content":"关注方向 对于自己的职业规划，可能是游戏研发一条路走到黑了，如果有什么其他想法的话，可以也是web3游戏开发了吧。对于马上奔三的人，行为处事也变得稳当谨慎了。 对于技术方面，主要关注以下方面： go语言 k8s容器部署与编排 devops研运一体化 分布式系统架构 ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"关于作者","uri":"/about/"},{"categories":null,"content":"关于博客 最早开始写博客可以追溯到大一，到现在工作快五年了，也经历了差不多8年，很遗憾期间走走停停没能坚持下来，自己也总结了原因，最大的问题还是自己恒心不够，其他原因还有技术积淀不足，产出的文章内容不够充实。另外，博客写作平台也是一直在切换，从自建博客wordpress，到简书、csdn等平台，在写作体验上总有各种缺点，其实我个人非常喜欢简洁的写作体验，就好似代码编程一样。 现在博客是采用hugo静态编译markdown的方式，相对于之前的方案，优点如下： 写作方式：纯markdown编辑体验，本地编辑器写作，流程丝滑。 文章管理：等同于git仓库的md文件管理，随心所欲整理，git多版本管理。 部署流程：github action自动化部署，提交自动走发布流程，丝滑到极致。 自定义：博客所有权都归自己，有点类似web3的思想，我的草原我的马，我想咋耍就咋耍。 …… 缺点也是有一些的，那就是需要一定的动手能力，但也不会太折腾，毕竟已经有很多前辈踩过坑了，致敬 👏 所以，希望自己能产出更多优质的内容，在这里遇到更多志同道合的朋友，大家一起技术进步! ","date":"2019-08-02","objectID":"/about/:0:3","tags":null,"title":"关于作者","uri":"/about/"}]