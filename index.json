[{"categories":["编程"],"content":"测试内容… ","date":"2023-02-15","objectID":"/first-post/:0:0","tags":["区块链","move"],"title":"First Post","uri":"/first-post/"},{"categories":["编程"],"content":"Go 的设计是一种简单哲学，它摒弃了其他语言一些臃肿的功能和模块，以降低程序员的学习门槛，减少使用中的心智负担。 本文，我们来探讨 Go 中缺失的数据结构：Set，以及它的最佳实现方案。 ","date":"2022-04-15","objectID":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/:0:0","tags":["golang","数据结构"],"title":"go的set实现方案","uri":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"Set 语义与实现方案 Set 集合是其他语言中常见的数据结构。特性：集合中的对象不按特定的方式排序，并且没有重复对象。 学习 Go ，要记住：Go 没有包含的东西，不代表 Go 真的没有。根据 Set 特性，我们可以很轻松地想到使用 map 的实现方案（因为 map 的 key 是不重复的）：把对象当做 key 存入 map。 使用 map 来实现 Set，意味着我们只关心 key 的存在，其 value 值并不重要。有其他语言编程经验的人也许会选择 bool 来作为 value，因为它是其它语言中内存消耗最少的类型（1个字节）。但是在 Go 中，还有另一种选择：struct{}。 fmt.Println(unsafe.Sizeof(struct {}{})) // output: 0 ","date":"2022-04-15","objectID":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/:1:0","tags":["golang","数据结构"],"title":"go的set实现方案","uri":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"压测对比 为了探究哪种数据结构是作为 value 的最佳选择。我们选择了以下常用的类型作为 value 进行测试：bool、int、interface{}、struct{}。 package main import ( \"testing\" ) const num = int(1 \u003c\u003c 24) // 测试 bool 类型 func Benchmark_SetWithBoolValueWrite(b *testing.B) { set := make(map[int]bool) for i := 0; i \u003c num; i++ { set[i] = true } } // 测试 interface{} 类型 func Benchmark_SetWithInterfaceValueWrite(b *testing.B) { set := make(map[int]interface{}) for i := 0; i \u003c num; i++ { set[i] = struct{}{} } } // 测试 int 类型 func Benchmark_SetWithIntValueWrite(b *testing.B) { set := make(map[int]int) for i := 0; i \u003c num; i++ { set[i] = 0 } } // 测试 struct{} 类型 func Benchmark_SetWithStructValueWrite(b *testing.B) { set := make(map[int]struct{}) for i := 0; i \u003c num; i++ { set[i] = struct{}{} } } 我们运行以下命令，进行测试 $ go test -v -bench=. -count=3 -benchmem | tee result.txt goos: darwin goarch: amd64 pkg: workspace/example/demoForSet cpu: Intel(R) Core(TM) i5-8279U CPU @ 2.40GHz Benchmark_SetWithBoolValueWrite Benchmark_SetWithBoolValueWrite-8 1 3549312568 ns/op 883610264 B/op 614311 allocs/op Benchmark_SetWithBoolValueWrite-8 1 3288521519 ns/op 883599440 B/op 614206 allocs/op Benchmark_SetWithBoolValueWrite-8 1 3264097496 ns/op 883578624 B/op 614003 allocs/op Benchmark_SetWithInterfaceValueWrite Benchmark_SetWithInterfaceValueWrite-8 1 4397757645 ns/op 1981619632 B/op 614062 allocs/op Benchmark_SetWithInterfaceValueWrite-8 1 4088301215 ns/op 1981553392 B/op 613743 allocs/op Benchmark_SetWithInterfaceValueWrite-8 1 3990698218 ns/op 1981560880 B/op 613773 allocs/op Benchmark_SetWithIntValueWrite Benchmark_SetWithIntValueWrite-8 1 3472910194 ns/op 1412326480 B/op 615131 allocs/op Benchmark_SetWithIntValueWrite-8 1 3519755137 ns/op 1412187928 B/op 614294 allocs/op Benchmark_SetWithIntValueWrite-8 1 3459182691 ns/op 1412057672 B/op 613390 allocs/op Benchmark_SetWithStructValueWrite Benchmark_SetWithStructValueWrite-8 1 3126746088 ns/op 802452368 B/op 614127 allocs/op Benchmark_SetWithStructValueWrite-8 1 3161650835 ns/op 802431240 B/op 613632 allocs/op Benchmark_SetWithStructValueWrite-8 1 3160410871 ns/op 802440552 B/op 613748 allocs/op PASS ok workspace/example/demoForSet 42.660s 此时的结果看起来不太直观，这里推荐一个 benchmark 统计工具：Benchstat。通过以下命令进行安装 $ go get -u golang.org/x/perf/cmd/benchstat 使用 benchstat 分析刚才得到的 benchmark 结果文件 $ benchstat result.txt name time/op _SetWithBoolValueWrite-8 3.37s ± 5% _SetWithInterfaceValueWrite-8 4.16s ± 6% _SetWithIntValueWrite-8 3.48s ± 1% _SetWithStructValueWrite-8 3.15s ± 1% name alloc/op _SetWithBoolValueWrite-8 884MB ± 0% _SetWithInterfaceValueWrite-8 1.98GB ± 0% _SetWithIntValueWrite-8 1.41GB ± 0% _SetWithStructValueWrite-8 802MB ± 0% name allocs/op _SetWithBoolValueWrite-8 614k ± 0% _SetWithInterfaceValueWrite-8 614k ± 0% _SetWithIntValueWrite-8 614k ± 0% _SetWithStructValueWrite-8 614k ± 0% 从内存开销而言，struct{} 是最小的，反映在执行时间上也是最少的。由于 bool 类型仅占一个字节，它相较于空结构而言，相差的并不多。但是，如果使用 interface{} 类型，那差距就很明显了。 所以，毫无疑问，在 Set 的实现中， map 值类型应该选 struct{}。 ","date":"2022-04-15","objectID":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/:2:0","tags":["golang","数据结构"],"title":"go的set实现方案","uri":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"总结 本文虽然讨论的是 Set 的实现方案，但本质是涉及空结构体 struct{}{} 的 零内存特性。 空结构体除了是实现 Set 的 value 值最佳方案，它还可以应用于以下方面： 通知信号的 channel：当 channel 只用于通知 goroutine 的执行事件，此时 channel 就不需要发送任何实质性的数据，选择使用 chan struct{} 。 没有状态数据的结构体：当对象只拥有方法，而不包含任何的属性字段时，选择使用空结构体定义该对象。 ","date":"2022-04-15","objectID":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/:3:0","tags":["golang","数据结构"],"title":"go的set实现方案","uri":"/go%E7%9A%84set%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"},{"categories":["编程"],"content":"最近在读Go源码时发现高频注释语句“XXX must not be copied after first use“。例如sync包下的Pool、Cond、WaitGroup、Mutex、Map和atomoic.Vaule、strings.Builder等，都有该句注释。 ","date":"2021-02-11","objectID":"/nocopy%E6%9C%BA%E5%88%B6/:0:0","tags":["golang"],"title":"noCopy机制","uri":"/nocopy%E6%9C%BA%E5%88%B6/"},{"categories":["编程"],"content":"为什么注释文档中要强调no copy？ 安全！ 如果结构体对象包含指针字段，当该对象被拷贝时，会使得两个对象中的指针字段变得不再安全。 type S struct { f1 int f2 *s } type s struct { name string } func main() { mOld := S{ f1: 0, f2: \u0026s{name: \"mike\"}, } mNew := mOld //拷贝 mNew.f1 = 1 mNew.f2.name = \"jane\" fmt.Println(mOld.f1, mOld.f2) //输出：0 \u0026{jane} } 如上，结构体对象S中存在两个field，分别是f1和f2，其中f2是指向s类型的指针。当mNew复制了mOld之后，mNew对两个字段进行了改变，可以看到f1字段的更改，不会对mOld造成影响。但是，nNew中f2字段的修改也会把mOld中的f2字段修改掉，这引发了安全问题。 ","date":"2021-02-11","objectID":"/nocopy%E6%9C%BA%E5%88%B6/:1:0","tags":["golang"],"title":"noCopy机制","uri":"/nocopy%E6%9C%BA%E5%88%B6/"},{"categories":["编程"],"content":"Go是如何保证no copy的？ ","date":"2021-02-11","objectID":"/nocopy%E6%9C%BA%E5%88%B6/:2:0","tags":["golang"],"title":"noCopy机制","uri":"/nocopy%E6%9C%BA%E5%88%B6/"},{"categories":["编程"],"content":"runtime checking strings.Builder中copy检查 func main() { var a strings.Builder a.Write([]byte(\"a\")) b := a b.Write([]byte(\"b\")) } // 运行报错：strings: illegal use of non-zero Builder copied by value 报错信息，来源于strings.Builder的copyCheck。 type Builder struct { addr *Builder // of receiver, to detect copies by value buf []byte } func (b *Builder) Write(p []byte) (int, error) { b.copyCheck() b.buf = append(b.buf, p...) return len(p), nil } func (b *Builder) copyCheck() { if b.addr == nil { b.addr = (*Builder)(noescape(unsafe.Pointer(b))) } else if b.addr != b { panic(\"strings: illegal use of non-zero Builder copied by value\") } } 在Builder中，addr是一个指向自身的指针。当对上文中的a复制给b时，a和b本身是不同的对象。因此，b.addr实际还是指向a的指针，这就会触发条件b.addr!=b，造成panic。 sync.Cond中copy检查 在源码中，拥有copy检查机制的还有sync.Cond。 type Cond struct { noCopy noCopy L Locker notify notifyList checker copyChecker } func (c *Cond) Wait() { c.checker.check() ... } type copyChecker uintptr func (c *copyChecker) check() { if uintptr(*c) != uintptr(unsafe.Pointer(c)) \u0026\u0026 !atomic.CompareAndSwapUintptr((*uintptr)(c), 0, uintptr(unsafe.Pointer(c))) \u0026\u0026 uintptr(*c) != uintptr(unsafe.Pointer(c)) { panic(\"sync.Cond is copied\") } } 这里的check函数初看不易明白。因此，定义一个相似的结构体对象，来探究这里的check函数究竟是如何做copy检查的。 type cond struct { checker copyChecker } type copyChecker uintptr func (c *copyChecker) check() { fmt.Printf(\"Before: c: %12v, *c: %12v, uintptr(*c): %12v, uintptr(unsafe.Pointer(c)): %12v\\n\", c, *c, uintptr(*c), uintptr(unsafe.Pointer(c))) swapped := atomic.CompareAndSwapUintptr((*uintptr)(c), 0, uintptr(unsafe.Pointer(c))) fmt.Printf(\"After : c: %12v, *c: %12v, uintptr(*c): %12v, uintptr(unsafe.Pointer(c)): %12v, swapped: %12v\\n\", c, *c, uintptr(*c), uintptr(unsafe.Pointer(c)), swapped) } func main() { var a cond a.checker.check() b := a b.checker.check() } // 输出 Before: c: 0xc0000b4008, *c: 0, uintptr(*c): 0, uintptr(unsafe.Pointer(c)): 824634458120 After : c: 0xc0000b4008, *c: 824634458120, uintptr(*c): 824634458120, uintptr(unsafe.Pointer(c)): 824634458120, swapped: true Before: c: 0xc0000b4040, *c: 824634458120, uintptr(*c): 824634458120, uintptr(unsafe.Pointer(c)): 824634458176 After : c: 0xc0000b4040, *c: 824634458120, uintptr(*c): 824634458120, uintptr(unsafe.Pointer(c)): 824634458176, swapped: false 这下，sync.Cond的copy检查就很清晰了。当a被b copy之后，uintptr(*c)和uintptr(unsafe.Pointer(c))的值是不同的，通过uint对象的原子比较方法CompareAndSwapUintptr将返回false，它证明了对象a被copy过，从而调用panic保护sync.Cond不被复制。 ","date":"2021-02-11","objectID":"/nocopy%E6%9C%BA%E5%88%B6/:2:1","tags":["golang"],"title":"noCopy机制","uri":"/nocopy%E6%9C%BA%E5%88%B6/"},{"categories":["编程"],"content":"go vet checking 上述两个例子都是在程序编译后，runtime检查的。但是，正如文中开篇所述，sync包下的其他的对象如Pool、WaitGroup、Mutex、Map等，它们其实也需要copy检查机制，但是在源码中，却没有提供运行时检查。那该如何保证我们的代码中这些对象在使用中未被copy，从而避免潜在的安全问题呢？ Go在源代码src/sync/cond.go中的一段注释给了我们答案。 // noCopy may be embedded into structs which must not be copied // after the first use. // // See https://golang.org/issues/8005#issuecomment-190753527 // for details. type noCopy struct{} // Lock is a no-op used by -copylocks checker from `go vet`. func (*noCopy) Lock() {} func (*noCopy) Unlock() {} 很明显，runtime时的copy检查虽然很重要，但是，该操作会影响程序的执行性能。Go官方目前只提供了strings.Builder和sync.Cond的runtime拷贝检查机制，对于其他需要nocopy对象类型来说，使用go vet工具来做静态编译检查。 具体实施来说，就是该对象，或对象中存在filed，它拥有Lock()和Unlock()方法，即实现sync.Locker接口。之后，可以通过go vet功能，来检查代码中该对象是否有被copy。 例如sync.Pool和sync.WaitGroup就内嵌了noCopy属性，sync.Mutex实现了sync.Locker接口，sync.Map内嵌了sync.Mutex。 静态检查 // wg.go package main import \"sync\" func main() { var sm sync.Mutex sm.Lock() sm.Unlock() sm2 := sm sm2.Lock() } 如上，sm在first use后，被copy给sm2。注意：该代码运行时，不会报错，但是却存在安全隐患。 $ go vet wg.go # command-line-arguments ./wg.go:9:9: assignment copies lock value to sm2: sync.Mutex 通过以上命令，即可检查出sync.Mutex有被copy。因此，举一反三，如果在我们自己的项目开发中，定义某对象不能被copy，那么就可以参考Go源码中，嵌入noCopy结构体，最终通过go vet进行copy检查。 type noCopy struct{} func (*noCopy) Lock() {} func (*noCopy) Unlock() {} type MyType struct { noCopy noCopy ... } ","date":"2021-02-11","objectID":"/nocopy%E6%9C%BA%E5%88%B6/:2:2","tags":["golang"],"title":"noCopy机制","uri":"/nocopy%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"关于 LoveIt","date":"2019-08-02","objectID":"/about/","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"  LoveIt 是一个由  Dillon 开发的简洁、优雅且高效的 Hugo 博客主题。 它的原型基于 LeaveIt 主题 和 KeepIt 主题。 Hugo 主题 LoveIt ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"特性 ","date":"2019-08-02","objectID":"/about/:1:0","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"性能和 SEO  性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分  使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化  支持 Google Analytics  支持 Fathom Analytics  支持 Plausible Analytics  支持 Yandex Metrica  支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu)  支持所有第三方库的 CDN  基于 lazysizes 自动转换图片为懒加载 ","date":"2019-08-02","objectID":"/about/:1:1","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"外观和布局  桌面端/移动端 响应式布局  浅色/深色 主题模式  全局一致的设计语言  支持分页  易用和自动展开的文章目录  支持多语言和国际化  美观的 CSS 动画 社交和评论系统  支持 Gravatar 头像  支持本地头像  支持多达 73 种社交链接  支持多达 24 种网站分享  支持 Disqus 评论系统  支持 Gitalk 评论系统  支持 Valine 评论系统  支持 Facebook comments 评论系统  支持 Telegram comments 评论系统  支持 Commento 评论系统  支持 utterances 评论系统  支持 giscus 评论系统 ","date":"2019-08-02","objectID":"/about/:1:2","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"扩展功能  支持基于 Lunr.js 或 algolia 的搜索  支持 Twemoji  支持代码高亮  一键复制代码到剪贴板  支持基于 lightGallery 的图片画廊  支持 Font Awesome 图标的扩展 Markdown 语法  支持上标注释的扩展 Markdown 语法  支持分数的扩展 Markdown 语法  支持基于 $\\KaTeX$ 的数学公式  支持基于 mermaid 的图表 shortcode  支持基于 ECharts 的交互式数据可视化 shortcode  支持基于 Mapbox GL JS 的 Mapbox shortcode  支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode  支持 Bilibili 视频 shortcode  支持多种注释的 shortcode  支持自定义样式的 shortcode  支持自定义脚本的 shortcode  支持基于 TypeIt 的打字动画 shortcode  支持基于 cookieconsent 的 Cookie 许可横幅  支持人物标签的 shortcode … ","date":"2019-08-02","objectID":"/about/:1:3","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"许可协议 LoveIt 根据 MIT 许可协议授权。 更多信息请查看 LICENSE 文件。 ","date":"2019-08-02","objectID":"/about/:2:0","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"特别感谢 LoveIt 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css autocomplete Lunr.js algoliasearch lazysizes object-fit-images Twemoji emoji-data lightGallery clipboard.js Sharer.js TypeIt $\\KaTeX$ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:3:0","tags":null,"title":"关于 LoveIt","uri":"/about/"}]